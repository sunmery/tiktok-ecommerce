// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: category.sql

package models

import (
	"context"
	"time"
)

const BatchGetCategories = `-- name: BatchGetCategories :many
SELECT
    id,
    COALESCE(parent_id, 0) AS parent_id,
    level,
    path::text AS path,
    name,
    sort_order,
    is_leaf,
    created_at,
    updated_at
FROM categories.categories
WHERE id = ANY($1::bigint[])
`

type BatchGetCategoriesRow struct {
	ID        int64
	ParentID  int64
	Level     int16
	Path      string
	Name      string
	SortOrder int16
	IsLeaf    bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

// BatchGetCategories
//
//	SELECT
//	    id,
//	    COALESCE(parent_id, 0) AS parent_id,
//	    level,
//	    path::text AS path,
//	    name,
//	    sort_order,
//	    is_leaf,
//	    created_at,
//	    updated_at
//	FROM categories.categories
//	WHERE id = ANY($1::bigint[])
func (q *Queries) BatchGetCategories(ctx context.Context, dollar_1 []int64) ([]BatchGetCategoriesRow, error) {
	rows, err := q.db.Query(ctx, BatchGetCategories, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BatchGetCategoriesRow
	for rows.Next() {
		var i BatchGetCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.Level,
			&i.Path,
			&i.Name,
			&i.SortOrder,
			&i.IsLeaf,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const CreateCategory = `-- name: CreateCategory :one
/*
参数说明：
- parent_id: 父分类ID（0表示根）
- name: 分类名称
- sort_order: 排序序号

操作流程：
1. 检查父分类是否存在
2. 插入新分类并生成ltree路径
3. 维护闭包表关系
*/

WITH parent_cte AS (
    SELECT id, level, path
    FROM categories.categories
    WHERE id = CASE
        WHEN $1::bigint = 0 THEN 1
        WHEN $1::bigint IS NULL THEN 1
        ELSE $1::bigint
    END
),
valid_parent AS (
    SELECT id, level, path
    FROM parent_cte
    WHERE level < 6
    AND EXISTS(SELECT 1 FROM categories.categories WHERE id = (SELECT id FROM parent_cte))
),
new_category AS (
    INSERT INTO categories.categories (
        id, parent_id, name, sort_order, level, path, is_leaf
    )
    SELECT
        nextval('categories.categories_id_seq'),
        p.id,
        $2::varchar(50),
        $3::smallint,
        p.level + 1,
        p.path || currval('categories.categories_id_seq')::text::ltree,
        true
    FROM valid_parent p
    WHERE NOT EXISTS (
        SELECT 1 FROM categories.categories
        WHERE parent_id = p.id AND name = $2::varchar(50)
    )
    RETURNING id, parent_id, level, path, name, sort_order, is_leaf, created_at, updated_at
),
update_leaf AS (
    UPDATE categories.categories
    SET is_leaf = false
    WHERE id = (SELECT parent_id FROM new_category)
    AND is_leaf = true
),
update_current_leaf AS (
    UPDATE categories.categories
    SET is_leaf = NOT EXISTS (
        SELECT 1 FROM categories.categories
        WHERE parent_id = (SELECT id FROM new_category)
    )
    WHERE id = (SELECT id FROM new_category)
),
closure_insert AS (
    INSERT INTO categories.category_closure (ancestor, descendant, depth)
    SELECT
        c.ancestor,
        n.id,
        c.depth + 1
    FROM categories.category_closure c
    CROSS JOIN new_category n
    WHERE c.descendant = (SELECT id FROM valid_parent)
    UNION ALL
    SELECT
        n.id,
        n.id,
        0
    FROM new_category n
)
SELECT id, parent_id, level, path, name, sort_order, is_leaf, created_at, updated_at FROM new_category
`

type CreateCategoryParams struct {
	ParentID  int64
	Name      string
	SortOrder int16
}

type CreateCategoryRow struct {
	ID        int64
	ParentID  *int64
	Level     int16
	Path      string
	Name      string
	SortOrder int16
	IsLeaf    bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

// CreateCategory
//
//	/*
//	参数说明：
//	- parent_id: 父分类ID（0表示根）
//	- name: 分类名称
//	- sort_order: 排序序号
//
//	操作流程：
//	1. 检查父分类是否存在
//	2. 插入新分类并生成ltree路径
//	3. 维护闭包表关系
//	*/
//
//	WITH parent_cte AS (
//	    SELECT id, level, path
//	    FROM categories.categories
//	    WHERE id = CASE
//	        WHEN $1::bigint = 0 THEN 1
//	        WHEN $1::bigint IS NULL THEN 1
//	        ELSE $1::bigint
//	    END
//	),
//	valid_parent AS (
//	    SELECT id, level, path
//	    FROM parent_cte
//	    WHERE level < 6
//	    AND EXISTS(SELECT 1 FROM categories.categories WHERE id = (SELECT id FROM parent_cte))
//	),
//	new_category AS (
//	    INSERT INTO categories.categories (
//	        id, parent_id, name, sort_order, level, path, is_leaf
//	    )
//	    SELECT
//	        nextval('categories.categories_id_seq'),
//	        p.id,
//	        $2::varchar(50),
//	        $3::smallint,
//	        p.level + 1,
//	        p.path || currval('categories.categories_id_seq')::text::ltree,
//	        true
//	    FROM valid_parent p
//	    WHERE NOT EXISTS (
//	        SELECT 1 FROM categories.categories
//	        WHERE parent_id = p.id AND name = $2::varchar(50)
//	    )
//	    RETURNING id, parent_id, level, path, name, sort_order, is_leaf, created_at, updated_at
//	),
//	update_leaf AS (
//	    UPDATE categories.categories
//	    SET is_leaf = false
//	    WHERE id = (SELECT parent_id FROM new_category)
//	    AND is_leaf = true
//	),
//	update_current_leaf AS (
//	    UPDATE categories.categories
//	    SET is_leaf = NOT EXISTS (
//	        SELECT 1 FROM categories.categories
//	        WHERE parent_id = (SELECT id FROM new_category)
//	    )
//	    WHERE id = (SELECT id FROM new_category)
//	),
//	closure_insert AS (
//	    INSERT INTO categories.category_closure (ancestor, descendant, depth)
//	    SELECT
//	        c.ancestor,
//	        n.id,
//	        c.depth + 1
//	    FROM categories.category_closure c
//	    CROSS JOIN new_category n
//	    WHERE c.descendant = (SELECT id FROM valid_parent)
//	    UNION ALL
//	    SELECT
//	        n.id,
//	        n.id,
//	        0
//	    FROM new_category n
//	)
//	SELECT id, parent_id, level, path, name, sort_order, is_leaf, created_at, updated_at FROM new_category
func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (CreateCategoryRow, error) {
	row := q.db.QueryRow(ctx, CreateCategory, arg.ParentID, arg.Name, arg.SortOrder)
	var i CreateCategoryRow
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Level,
		&i.Path,
		&i.Name,
		&i.SortOrder,
		&i.IsLeaf,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteCategory = `-- name: DeleteCategory :exec
WITH deleted_nodes AS (
    DELETE FROM categories.categories
        WHERE path <@ (SELECT path FROM categories.categories WHERE id = $1)
            OR path ~ ($2 || '.*{1,}')::lquery
        RETURNING id, parent_id
),
     delete_closure AS (
         DELETE FROM categories.category_closure
             WHERE descendant IN (SELECT id FROM deleted_nodes)
                 OR ancestor IN (SELECT id FROM deleted_nodes)
     )
UPDATE categories.categories
SET is_leaf = (
    SELECT NOT EXISTS (
        SELECT 1 FROM categories.categories
        WHERE parent_id = (SELECT parent_id FROM deleted_nodes LIMIT 1)
          AND id != (SELECT id FROM deleted_nodes LIMIT 1)
    )
)
WHERE id = (SELECT parent_id FROM deleted_nodes LIMIT 1)
  AND (SELECT parent_id FROM deleted_nodes LIMIT 1) IS NOT NULL
`

type DeleteCategoryParams struct {
	ID   *int64
	Path *string
}

// DeleteCategory
//
//	WITH deleted_nodes AS (
//	    DELETE FROM categories.categories
//	        WHERE path <@ (SELECT path FROM categories.categories WHERE id = $1)
//	            OR path ~ ($2 || '.*{1,}')::lquery
//	        RETURNING id, parent_id
//	),
//	     delete_closure AS (
//	         DELETE FROM categories.category_closure
//	             WHERE descendant IN (SELECT id FROM deleted_nodes)
//	                 OR ancestor IN (SELECT id FROM deleted_nodes)
//	     )
//	UPDATE categories.categories
//	SET is_leaf = (
//	    SELECT NOT EXISTS (
//	        SELECT 1 FROM categories.categories
//	        WHERE parent_id = (SELECT parent_id FROM deleted_nodes LIMIT 1)
//	          AND id != (SELECT id FROM deleted_nodes LIMIT 1)
//	    )
//	)
//	WHERE id = (SELECT parent_id FROM deleted_nodes LIMIT 1)
//	  AND (SELECT parent_id FROM deleted_nodes LIMIT 1) IS NOT NULL
func (q *Queries) DeleteCategory(ctx context.Context, arg DeleteCategoryParams) error {
	_, err := q.db.Exec(ctx, DeleteCategory, arg.ID, arg.Path)
	return err
}

const GetCategories = `-- name: GetCategories :one
SELECT
    id,
    COALESCE(parent_id, 0) AS parent_id,
    level,
    path::text AS path,
    name,
    sort_order,
    is_leaf,
    created_at,
    updated_at
FROM categories.categories
WHERE id = $1
`

type GetCategoriesRow struct {
	ID        int64
	ParentID  int64
	Level     int16
	Path      string
	Name      string
	SortOrder int16
	IsLeaf    bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

// GetCategories
//
//	SELECT
//	    id,
//	    COALESCE(parent_id, 0) AS parent_id,
//	    level,
//	    path::text AS path,
//	    name,
//	    sort_order,
//	    is_leaf,
//	    created_at,
//	    updated_at
//	FROM categories.categories
//	WHERE id = $1
func (q *Queries) GetCategories(ctx context.Context, id int64) (GetCategoriesRow, error) {
	row := q.db.QueryRow(ctx, GetCategories, id)
	var i GetCategoriesRow
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Level,
		&i.Path,
		&i.Name,
		&i.SortOrder,
		&i.IsLeaf,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetCategory = `-- name: GetCategory :one
SELECT
    id,
    COALESCE(parent_id, 0) AS parent_id,  -- 将NULL转换为0返回给proto
    level,
    path::text AS path,
    name,
    sort_order,
    is_leaf,
    created_at,
    updated_at
FROM categories.categories WHERE id = $1
`

type GetCategoryRow struct {
	ID        int64
	ParentID  int64
	Level     int16
	Path      string
	Name      string
	SortOrder int16
	IsLeaf    bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

// GetCategory
//
//	SELECT
//	    id,
//	    COALESCE(parent_id, 0) AS parent_id,  -- 将NULL转换为0返回给proto
//	    level,
//	    path::text AS path,
//	    name,
//	    sort_order,
//	    is_leaf,
//	    created_at,
//	    updated_at
//	FROM categories.categories WHERE id = $1
func (q *Queries) GetCategory(ctx context.Context, id int64) (GetCategoryRow, error) {
	row := q.db.QueryRow(ctx, GetCategory, id)
	var i GetCategoryRow
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Level,
		&i.Path,
		&i.Name,
		&i.SortOrder,
		&i.IsLeaf,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetCategoryPath = `-- name: GetCategoryPath :many
SELECT
    c.id,
    COALESCE(c.parent_id, 0) AS parent_id,
    c.level,
    c.path::text,
    c.name,
    c.sort_order,
    c.is_leaf,
    c.created_at,
    c.updated_at
FROM categories.category_closure cc
         JOIN categories.categories c ON cc.ancestor = c.id
WHERE cc.descendant = $1
ORDER BY cc.depth DESC
`

type GetCategoryPathRow struct {
	ID        int64
	ParentID  int64
	Level     int16
	CPath     string
	Name      string
	SortOrder int16
	IsLeaf    bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

// GetCategoryPath
//
//	SELECT
//	    c.id,
//	    COALESCE(c.parent_id, 0) AS parent_id,
//	    c.level,
//	    c.path::text,
//	    c.name,
//	    c.sort_order,
//	    c.is_leaf,
//	    c.created_at,
//	    c.updated_at
//	FROM categories.category_closure cc
//	         JOIN categories.categories c ON cc.ancestor = c.id
//	WHERE cc.descendant = $1
//	ORDER BY cc.depth DESC
func (q *Queries) GetCategoryPath(ctx context.Context, descendant int64) ([]GetCategoryPathRow, error) {
	rows, err := q.db.Query(ctx, GetCategoryPath, descendant)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategoryPathRow
	for rows.Next() {
		var i GetCategoryPathRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.Level,
			&i.CPath,
			&i.Name,
			&i.SortOrder,
			&i.IsLeaf,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetClosureRelations = `-- name: GetClosureRelations :many
SELECT ancestor, descendant, depth FROM categories.category_closure
WHERE descendant = $1
`

// GetClosureRelations
//
//	SELECT ancestor, descendant, depth FROM categories.category_closure
//	WHERE descendant = $1
func (q *Queries) GetClosureRelations(ctx context.Context, descendant int64) ([]CategoriesCategoryClosure, error) {
	rows, err := q.db.Query(ctx, GetClosureRelations, descendant)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CategoriesCategoryClosure
	for rows.Next() {
		var i CategoriesCategoryClosure
		if err := rows.Scan(&i.Ancestor, &i.Descendant, &i.Depth); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDirectSubCategories = `-- name: GetDirectSubCategories :many
SELECT
    id,
    COALESCE(parent_id, 0) AS parent_id,
    level,
    path::text AS cpath,
    name,
    sort_order,
    is_leaf,
    created_at,
    updated_at
FROM categories.categories
WHERE parent_id = $1
ORDER BY sort_order, id
`

type GetDirectSubCategoriesRow struct {
	ID        int64
	ParentID  int64
	Level     int16
	Cpath     string
	Name      string
	SortOrder int16
	IsLeaf    bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

// GetDirectSubCategories
//
//	SELECT
//	    id,
//	    COALESCE(parent_id, 0) AS parent_id,
//	    level,
//	    path::text AS cpath,
//	    name,
//	    sort_order,
//	    is_leaf,
//	    created_at,
//	    updated_at
//	FROM categories.categories
//	WHERE parent_id = $1
//	ORDER BY sort_order, id
func (q *Queries) GetDirectSubCategories(ctx context.Context, parentID *int64) ([]GetDirectSubCategoriesRow, error) {
	rows, err := q.db.Query(ctx, GetDirectSubCategories, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDirectSubCategoriesRow
	for rows.Next() {
		var i GetDirectSubCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.Level,
			&i.Cpath,
			&i.Name,
			&i.SortOrder,
			&i.IsLeaf,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetLeafCategories = `-- name: GetLeafCategories :many
SELECT
    id,
    COALESCE(parent_id, 0) AS parent_id,
    level,
    path::text,
    name,
    sort_order,
    is_leaf,
    created_at,
    updated_at
FROM categories.categories
WHERE level != 0
`

type GetLeafCategoriesRow struct {
	ID        int64
	ParentID  int64
	Level     int16
	Path      string
	Name      string
	SortOrder int16
	IsLeaf    bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

// GetLeafCategories
//
//	SELECT
//	    id,
//	    COALESCE(parent_id, 0) AS parent_id,
//	    level,
//	    path::text,
//	    name,
//	    sort_order,
//	    is_leaf,
//	    created_at,
//	    updated_at
//	FROM categories.categories
//	WHERE level != 0
func (q *Queries) GetLeafCategories(ctx context.Context) ([]GetLeafCategoriesRow, error) {
	rows, err := q.db.Query(ctx, GetLeafCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeafCategoriesRow
	for rows.Next() {
		var i GetLeafCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.Level,
			&i.Path,
			&i.Name,
			&i.SortOrder,
			&i.IsLeaf,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSubTree = `-- name: GetSubTree :many
WITH RECURSIVE category_tree AS (
    -- 基本情况：直接获取所有子节点作为起点
    SELECT
        c.id,
        c.parent_id,
        c.level,
        c.path,
        c.name,
        c.sort_order,
        c.is_leaf,
        c.created_at,
        c.updated_at
    FROM categories.categories c
    WHERE c.parent_id = $1
    
    UNION ALL
    
    -- 递归情况：获取所有直接子节点
    SELECT
        c.id,
        c.parent_id,
        c.level,
        c.path,
        c.name,
        c.sort_order,
        c.is_leaf,
        c.created_at,
        c.updated_at
    FROM categories.categories c
    JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT
    id,
    COALESCE(parent_id, 0) AS parent_id,
    level,
    path::text AS cpath,
    name,
    sort_order,
    is_leaf,
    created_at,
    updated_at
FROM category_tree
ORDER BY level, id
`

type GetSubTreeRow struct {
	ID        int64
	ParentID  int64
	Level     int16
	Cpath     string
	Name      string
	SortOrder int16
	IsLeaf    bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

// GetSubTree
//
//	WITH RECURSIVE category_tree AS (
//	    -- 基本情况：直接获取所有子节点作为起点
//	    SELECT
//	        c.id,
//	        c.parent_id,
//	        c.level,
//	        c.path,
//	        c.name,
//	        c.sort_order,
//	        c.is_leaf,
//	        c.created_at,
//	        c.updated_at
//	    FROM categories.categories c
//	    WHERE c.parent_id = $1
//
//	    UNION ALL
//
//	    -- 递归情况：获取所有直接子节点
//	    SELECT
//	        c.id,
//	        c.parent_id,
//	        c.level,
//	        c.path,
//	        c.name,
//	        c.sort_order,
//	        c.is_leaf,
//	        c.created_at,
//	        c.updated_at
//	    FROM categories.categories c
//	    JOIN category_tree ct ON c.parent_id = ct.id
//	)
//	SELECT
//	    id,
//	    COALESCE(parent_id, 0) AS parent_id,
//	    level,
//	    path::text AS cpath,
//	    name,
//	    sort_order,
//	    is_leaf,
//	    created_at,
//	    updated_at
//	FROM category_tree
//	ORDER BY level, id
func (q *Queries) GetSubTree(ctx context.Context, parentID *int64) ([]GetSubTreeRow, error) {
	rows, err := q.db.Query(ctx, GetSubTree, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubTreeRow
	for rows.Next() {
		var i GetSubTreeRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.Level,
			&i.Cpath,
			&i.Name,
			&i.SortOrder,
			&i.IsLeaf,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateCategory = `-- name: UpdateCategory :exec
UPDATE categories.categories
SET name = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateCategoryParams struct {
	ID   int64
	Name string
}

// UpdateCategory
//
//	UPDATE categories.categories
//	SET name = $2, updated_at = NOW()
//	WHERE id = $1
func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) error {
	_, err := q.db.Exec(ctx, UpdateCategory, arg.ID, arg.Name)
	return err
}

const UpdateClosureDepth = `-- name: UpdateClosureDepth :exec
UPDATE categories.category_closure
SET depth = depth + $2
WHERE descendant = $1
`

type UpdateClosureDepthParams struct {
	Descendant int64
	Depth      int16
}

// UpdateClosureDepth
//
//	UPDATE categories.category_closure
//	SET depth = depth + $2
//	WHERE descendant = $1
func (q *Queries) UpdateClosureDepth(ctx context.Context, arg UpdateClosureDepthParams) error {
	_, err := q.db.Exec(ctx, UpdateClosureDepth, arg.Descendant, arg.Depth)
	return err
}
