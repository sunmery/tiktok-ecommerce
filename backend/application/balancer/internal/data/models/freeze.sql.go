// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: freeze.sql

package models

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CreateFreeze = `-- name: CreateFreeze :one
INSERT INTO balances.balance_freezes (id, user_id, order_id, currency, amount, status, expires_at)
VALUES ($1, $2, $3, $4, $5, 'FROZEN', $6)
RETURNING id
`

type CreateFreezeParams struct {
	ID        int64              `json:"id"`
	UserID    uuid.UUID          `json:"userID"`
	OrderID   int64              `json:"orderID"`
	Currency  string             `json:"currency"`
	Amount    pgtype.Numeric     `json:"amount"`
	ExpiresAt pgtype.Timestamptz `json:"expiresAt"`
}

// 创建冻结记录
//
//	INSERT INTO balances.balance_freezes (id, user_id, order_id, currency, amount, status, expires_at)
//	VALUES ($1, $2, $3, $4, $5, 'FROZEN', $6)
//	RETURNING id
func (q *Queries) CreateFreeze(ctx context.Context, arg CreateFreezeParams) (int64, error) {
	row := q.db.QueryRow(ctx, CreateFreeze,
		arg.ID,
		arg.UserID,
		arg.OrderID,
		arg.Currency,
		arg.Amount,
		arg.ExpiresAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const GetExpiredFreezes = `-- name: GetExpiredFreezes :many

SELECT id, user_id, order_id, currency, amount, status, created_at, updated_at, expires_at
FROM balances.balance_freezes
WHERE status = 'FROZEN'
  AND expires_at < NOW()
`

// 确保当前状态是预期的状态 (例如 'FROZEN')
// 获取所有已过期但仍处于冻结状态的记录 (用于定时任务处理)
//
//	SELECT id, user_id, order_id, currency, amount, status, created_at, updated_at, expires_at
//	FROM balances.balance_freezes
//	WHERE status = 'FROZEN'
//	  AND expires_at < NOW()
func (q *Queries) GetExpiredFreezes(ctx context.Context) ([]BalancesBalanceFreezes, error) {
	rows, err := q.db.Query(ctx, GetExpiredFreezes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BalancesBalanceFreezes
	for rows.Next() {
		var i BalancesBalanceFreezes
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OrderID,
			&i.Currency,
			&i.Amount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetFreeze = `-- name: GetFreeze :one
SELECT id, user_id, order_id, currency, amount, status, created_at, updated_at, expires_at
FROM balances.balance_freezes
WHERE id = $1
`

// 根据 ID 获取冻结记录
//
//	SELECT id, user_id, order_id, currency, amount, status, created_at, updated_at, expires_at
//	FROM balances.balance_freezes
//	WHERE id = $1
func (q *Queries) GetFreeze(ctx context.Context, id int64) (BalancesBalanceFreezes, error) {
	row := q.db.QueryRow(ctx, GetFreeze, id)
	var i BalancesBalanceFreezes
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrderID,
		&i.Currency,
		&i.Amount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const GetFreezeByOrderForUser = `-- name: GetFreezeByOrderForUser :one
SELECT id, user_id, order_id, currency, amount, status, created_at, updated_at, expires_at
FROM balances.balance_freezes
WHERE user_id = $1
  AND order_id = $2
`

type GetFreezeByOrderForUserParams struct {
	UserID  uuid.UUID `json:"userID"`
	OrderID int64     `json:"orderID"`
}

// 根据用户 ID 和订单 ID 获取冻结记录 (假设一个订单只有一个冻结记录)
//
//	SELECT id, user_id, order_id, currency, amount, status, created_at, updated_at, expires_at
//	FROM balances.balance_freezes
//	WHERE user_id = $1
//	  AND order_id = $2
func (q *Queries) GetFreezeByOrderForUser(ctx context.Context, arg GetFreezeByOrderForUserParams) (BalancesBalanceFreezes, error) {
	row := q.db.QueryRow(ctx, GetFreezeByOrderForUser, arg.UserID, arg.OrderID)
	var i BalancesBalanceFreezes
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrderID,
		&i.Currency,
		&i.Amount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const UpdateFreezeStatus = `-- name: UpdateFreezeStatus :execrows
UPDATE balances.balance_freezes
SET status     = $1,
    updated_at = NOW()
WHERE id = $2
  AND status = $3
`

type UpdateFreezeStatusParams struct {
	Status        string `json:"status"`
	ID            int64  `json:"id"`
	CurrentStatus string `json:"currentStatus"`
}

// 更新冻结记录状态 (例如: FROZEN -> CONFIRMED 或 FROZEN -> CANCELED)
//
//	UPDATE balances.balance_freezes
//	SET status     = $1,
//	    updated_at = NOW()
//	WHERE id = $2
//	  AND status = $3
func (q *Queries) UpdateFreezeStatus(ctx context.Context, arg UpdateFreezeStatusParams) (int64, error) {
	result, err := q.db.Exec(ctx, UpdateFreezeStatus, arg.Status, arg.ID, arg.CurrentStatus)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
