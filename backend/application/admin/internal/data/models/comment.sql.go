// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: comment.sql

package models

import (
	"context"

	"github.com/google/uuid"
)

const CreateBulkSensitiveWords = `-- name: CreateBulkSensitiveWords :execrows
INSERT
INTO admin.sensitive_words(created_by, category, word, level, is_active)
SELECT unnest($1::UUID[]),
       unnest($2::VARCHAR[]),
       unnest($3::VARCHAR[]),
       unnest($4::INT[]),
       unnest($5::BOOL[])
ON CONFLICT (word) DO NOTHING
`

type CreateBulkSensitiveWordsParams struct {
	CreatedBy  []uuid.UUID `json:"createdBy"`
	Categories []string    `json:"categories"`
	Words      []string    `json:"words"`
	Level      []int32     `json:"level"`
	IsActive   []bool      `json:"isActive"`
}

// 跳过重复的敏感词
//
//	INSERT
//	INTO admin.sensitive_words(created_by, category, word, level, is_active)
//	SELECT unnest($1::UUID[]),
//	       unnest($2::VARCHAR[]),
//	       unnest($3::VARCHAR[]),
//	       unnest($4::INT[]),
//	       unnest($5::BOOL[])
//	ON CONFLICT (word) DO NOTHING
func (q *Queries) CreateBulkSensitiveWords(ctx context.Context, arg CreateBulkSensitiveWordsParams) (int64, error) {
	result, err := q.db.Exec(ctx, CreateBulkSensitiveWords,
		arg.CreatedBy,
		arg.Categories,
		arg.Words,
		arg.Level,
		arg.IsActive,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const DeleteSensitiveWords = `-- name: DeleteSensitiveWords :execrows
DELETE
FROM admin.sensitive_words
WHERE id = $1
`

// DeleteSensitiveWords
//
//	DELETE
//	FROM admin.sensitive_words
//	WHERE id = $1
func (q *Queries) DeleteSensitiveWords(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, DeleteSensitiveWords, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const GetSensitiveWords = `-- name: GetSensitiveWords :many
SELECT id, created_by, category, word, level, is_active, created_at, updated_at
FROM admin.sensitive_words
ORDER BY created_at DESC
LIMIT $2::INT OFFSET $1::INT
`

type GetSensitiveWordsParams struct {
	Page     int32 `json:"page"`
	PageSize int32 `json:"pageSize"`
}

// GetSensitiveWords
//
//	SELECT id, created_by, category, word, level, is_active, created_at, updated_at
//	FROM admin.sensitive_words
//	ORDER BY created_at DESC
//	LIMIT $2::INT OFFSET $1::INT
func (q *Queries) GetSensitiveWords(ctx context.Context, arg GetSensitiveWordsParams) ([]AdminSensitiveWords, error) {
	rows, err := q.db.Query(ctx, GetSensitiveWords, arg.Page, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminSensitiveWords
	for rows.Next() {
		var i AdminSensitiveWords
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.Category,
			&i.Word,
			&i.Level,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateSensitiveWord = `-- name: UpdateSensitiveWord :execrows
UPDATE admin.sensitive_words
SET category   = COALESCE($1, category),
    created_by = COALESCE($2, created_by),
    word       = COALESCE($3, word),
    level      = COALESCE($4, level),
    is_active  = COALESCE($5, is_active)
WHERE id = $6
`

type UpdateSensitiveWordParams struct {
	Category  string    `json:"category"`
	CreatedBy uuid.UUID `json:"createdBy"`
	Word      string    `json:"word"`
	Level     int32     `json:"level"`
	IsActive  bool      `json:"isActive"`
	ID        int32     `json:"id"`
}

// UpdateSensitiveWord
//
//	UPDATE admin.sensitive_words
//	SET category   = COALESCE($1, category),
//	    created_by = COALESCE($2, created_by),
//	    word       = COALESCE($3, word),
//	    level      = COALESCE($4, level),
//	    is_active  = COALESCE($5, is_active)
//	WHERE id = $6
func (q *Queries) UpdateSensitiveWord(ctx context.Context, arg UpdateSensitiveWordParams) (int64, error) {
	result, err := q.db.Exec(ctx, UpdateSensitiveWord,
		arg.Category,
		arg.CreatedBy,
		arg.Word,
		arg.Level,
		arg.IsActive,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
