// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: order.sql

package models

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const GetAllOrders = `-- name: GetAllOrders :many
SELECT os.id     AS sub_order_id,
       os.total_amount,
       os.currency,
       os.status AS payment_status,
       os.items,
       os.shipping_status,
       os.created_at,
       os.updated_at,
       oo.id     AS order_id,
       oo.user_id,
       json_build_object(
               'streetAddress', oo.street_address,
               'city', oo.city,
               'state', oo.state,
               'country', oo.country,
               'zipCode', oo.zip_code
       )         AS consumer_address,
       oo.email
FROM orders.sub_orders os
         JOIN orders.orders oo
              ON os.order_id = oo.id
group by oo.user_id, os.updated_at, os.id, os.id, os.total_amount, os.currency, os.status, os.items, os.shipping_status,
         os.created_at, os.updated_at, oo.id, oo.user_id, oo.email
ORDER BY os.created_at DESC
LIMIT $2 OFFSET $1
`

type GetAllOrdersParams struct {
	Page     *int64 `json:"page"`
	PageSize *int64 `json:"pageSize"`
}

type GetAllOrdersRow struct {
	SubOrderID      int64              `json:"subOrderID"`
	TotalAmount     interface{}        `json:"totalAmount"`
	Currency        string             `json:"currency"`
	PaymentStatus   string             `json:"paymentStatus"`
	Items           []byte             `json:"items"`
	ShippingStatus  string             `json:"shippingStatus"`
	CreatedAt       pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt       pgtype.Timestamptz `json:"updatedAt"`
	OrderID         int64              `json:"orderID"`
	UserID          uuid.UUID          `json:"userID"`
	ConsumerAddress []byte             `json:"consumerAddress"`
	Email           string             `json:"email"`
}

// GetAllOrders
//
//	SELECT os.id     AS sub_order_id,
//	       os.total_amount,
//	       os.currency,
//	       os.status AS payment_status,
//	       os.items,
//	       os.shipping_status,
//	       os.created_at,
//	       os.updated_at,
//	       oo.id     AS order_id,
//	       oo.user_id,
//	       json_build_object(
//	               'streetAddress', oo.street_address,
//	               'city', oo.city,
//	               'state', oo.state,
//	               'country', oo.country,
//	               'zipCode', oo.zip_code
//	       )         AS consumer_address,
//	       oo.email
//	FROM orders.sub_orders os
//	         JOIN orders.orders oo
//	              ON os.order_id = oo.id
//	group by oo.user_id, os.updated_at, os.id, os.id, os.total_amount, os.currency, os.status, os.items, os.shipping_status,
//	         os.created_at, os.updated_at, oo.id, oo.user_id, oo.email
//	ORDER BY os.created_at DESC
//	LIMIT $2 OFFSET $1
func (q *Queries) GetAllOrders(ctx context.Context, arg GetAllOrdersParams) ([]GetAllOrdersRow, error) {
	rows, err := q.db.Query(ctx, GetAllOrders, arg.Page, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllOrdersRow
	for rows.Next() {
		var i GetAllOrdersRow
		if err := rows.Scan(
			&i.SubOrderID,
			&i.TotalAmount,
			&i.Currency,
			&i.PaymentStatus,
			&i.Items,
			&i.ShippingStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrderID,
			&i.UserID,
			&i.ConsumerAddress,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
