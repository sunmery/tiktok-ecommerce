// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: product.sql

package models

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const GetMerchantProducts = `-- name: GetMerchantProducts :many
SELECT p.id,
       p.name,
       p.description,
       p.price,
       p.status,
       p.merchant_id,
       p.category_id,
       p.created_at,
       p.updated_at,
       i.stock,
       (SELECT jsonb_agg(jsonb_build_object(
               'url', pi.url,
               'is_primary', pi.is_primary,
               'sort_order', pi.sort_order
                         ))
        FROM products.product_images pi
        WHERE pi.merchant_id = p.merchant_id) AS images,
       pa.attributes,
       (SELECT jsonb_build_object(
                       'id', a.id,
                       'old_status', a.old_status,
                       'new_status', a.new_status,
                       'reason', a.reason,
                       'created_at', a.created_at
               )
        FROM products.product_audits a
        WHERE a.merchant_id = p.merchant_id
        ORDER BY a.created_at DESC
        LIMIT 1)                              AS latest_audit
FROM products.products p
         INNER JOIN products.inventory i
                    ON p.id = i.product_id AND p.merchant_id = i.merchant_id
         LEFT JOIN products.product_attributes pa
                   ON p.id = pa.product_id AND p.merchant_id = pa.merchant_id
WHERE p.merchant_id = $1
  AND p.deleted_at IS NULL
LIMIT $3 OFFSET $2
`

type GetMerchantProductsParams struct {
	MerchantID pgtype.UUID
	Page       *int64
	Pagesize   *int64
}

type GetMerchantProductsRow struct {
	ID          uuid.UUID
	Name        string
	Description *string
	Price       interface{}
	Status      int16
	MerchantID  uuid.UUID
	CategoryID  int64
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Stock       int32
	Images      []byte
	Attributes  []byte
	LatestAudit []byte
}

// GetMerchantProducts
//
//	SELECT p.id,
//	       p.name,
//	       p.description,
//	       p.price,
//	       p.status,
//	       p.merchant_id,
//	       p.category_id,
//	       p.created_at,
//	       p.updated_at,
//	       i.stock,
//	       (SELECT jsonb_agg(jsonb_build_object(
//	               'url', pi.url,
//	               'is_primary', pi.is_primary,
//	               'sort_order', pi.sort_order
//	                         ))
//	        FROM products.product_images pi
//	        WHERE pi.merchant_id = p.merchant_id) AS images,
//	       pa.attributes,
//	       (SELECT jsonb_build_object(
//	                       'id', a.id,
//	                       'old_status', a.old_status,
//	                       'new_status', a.new_status,
//	                       'reason', a.reason,
//	                       'created_at', a.created_at
//	               )
//	        FROM products.product_audits a
//	        WHERE a.merchant_id = p.merchant_id
//	        ORDER BY a.created_at DESC
//	        LIMIT 1)                              AS latest_audit
//	FROM products.products p
//	         INNER JOIN products.inventory i
//	                    ON p.id = i.product_id AND p.merchant_id = i.merchant_id
//	         LEFT JOIN products.product_attributes pa
//	                   ON p.id = pa.product_id AND p.merchant_id = pa.merchant_id
//	WHERE p.merchant_id = $1
//	  AND p.deleted_at IS NULL
//	LIMIT $3 OFFSET $2
func (q *Queries) GetMerchantProducts(ctx context.Context, arg GetMerchantProductsParams) ([]GetMerchantProductsRow, error) {
	rows, err := q.db.Query(ctx, GetMerchantProducts, arg.MerchantID, arg.Page, arg.Pagesize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchantProductsRow
	for rows.Next() {
		var i GetMerchantProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Status,
			&i.MerchantID,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Stock,
			&i.Images,
			&i.Attributes,
			&i.LatestAudit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateProduct = `-- name: UpdateProduct :exec
WITH update_product AS (
    UPDATE products.products
        SET name = coalesce($2, name),
            description = coalesce($3, description),
            price = coalesce($4, price),
            updated_at = now()
        WHERE id = $5
            AND merchant_id = $6
        RETURNING merchant_id,id),
     update_attr AS (
         UPDATE products.product_attributes
             SET attributes = $7,
                 updated_at = NOW()
             WHERE merchant_id = $6
                 AND product_id = $5
             RETURNING updated_at),
     update_image AS (
         UPDATE products.product_images
             SET url = $8
             WHERE merchant_id = $6
                 AND product_id = $5)
UPDATE products.inventory pi
SET stock      = $1,
    updated_at = now()
FROM update_product
WHERE update_product.merchant_id = pi.merchant_id
  AND update_product.id = pi.product_id
`

type UpdateProductParams struct {
	Stock       *int32
	Name        *string
	Description *string
	Price       pgtype.Numeric
	ProductID   pgtype.UUID
	MerchantID  pgtype.UUID
	Attributes  []byte
	Url         *string
}

// UpdateProduct
//
//	WITH update_product AS (
//	    UPDATE products.products
//	        SET name = coalesce($2, name),
//	            description = coalesce($3, description),
//	            price = coalesce($4, price),
//	            updated_at = now()
//	        WHERE id = $5
//	            AND merchant_id = $6
//	        RETURNING merchant_id,id),
//	     update_attr AS (
//	         UPDATE products.product_attributes
//	             SET attributes = $7,
//	                 updated_at = NOW()
//	             WHERE merchant_id = $6
//	                 AND product_id = $5
//	             RETURNING updated_at),
//	     update_image AS (
//	         UPDATE products.product_images
//	             SET url = $8
//	             WHERE merchant_id = $6
//	                 AND product_id = $5)
//	UPDATE products.inventory pi
//	SET stock      = $1,
//	    updated_at = now()
//	FROM update_product
//	WHERE update_product.merchant_id = pi.merchant_id
//	  AND update_product.id = pi.product_id
func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.Exec(ctx, UpdateProduct,
		arg.Stock,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.ProductID,
		arg.MerchantID,
		arg.Attributes,
		arg.Url,
	)
	return err
}
