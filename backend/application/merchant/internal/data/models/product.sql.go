// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: product.sql

package models

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const GetMerchantProducts = `-- name: GetMerchantProducts :many
SELECT p.id,
       p.name,
       p.description,
       p.price,
       p.status,
       p.merchant_id,
       p.category_id,
       p.created_at,
       p.updated_at,
       i.stock,
       (SELECT jsonb_agg(jsonb_build_object(
               'url', pi.url,
               'is_primary', pi.is_primary,
               'sort_order', pi.sort_order
                         ))
        FROM products.product_images pi
        WHERE pi.merchant_id = p.merchant_id) AS images,
       pa.attributes,
       (SELECT jsonb_build_object(
                       'id', a.id,
                       'old_status', a.old_status,
                       'new_status', a.new_status,
                       'reason', a.reason,
                       'created_at', a.created_at
               )
        FROM products.product_audits a
        WHERE a.merchant_id = p.merchant_id
        ORDER BY a.created_at DESC
        LIMIT 1)                              AS latest_audit
FROM products.products p
         INNER JOIN products.inventory i
                    ON p.id = i.product_id AND p.merchant_id = i.merchant_id
         LEFT JOIN products.product_attributes pa
                   ON p.id = pa.product_id AND p.merchant_id = pa.merchant_id
WHERE p.merchant_id = $1
  AND p.deleted_at IS NULL
LIMIT $3 OFFSET $2
`

type GetMerchantProductsParams struct {
	MerchantID pgtype.UUID
	Page       *int64
	Pagesize   *int64
}

type GetMerchantProductsRow struct {
	ID          uuid.UUID
	Name        string
	Description *string
	Price       interface{}
	Status      int16
	MerchantID  uuid.UUID
	CategoryID  int64
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Stock       int32
	Images      []byte
	Attributes  []byte
	LatestAudit []byte
}

// GetMerchantProducts
//
//	SELECT p.id,
//	       p.name,
//	       p.description,
//	       p.price,
//	       p.status,
//	       p.merchant_id,
//	       p.category_id,
//	       p.created_at,
//	       p.updated_at,
//	       i.stock,
//	       (SELECT jsonb_agg(jsonb_build_object(
//	               'url', pi.url,
//	               'is_primary', pi.is_primary,
//	               'sort_order', pi.sort_order
//	                         ))
//	        FROM products.product_images pi
//	        WHERE pi.merchant_id = p.merchant_id) AS images,
//	       pa.attributes,
//	       (SELECT jsonb_build_object(
//	                       'id', a.id,
//	                       'old_status', a.old_status,
//	                       'new_status', a.new_status,
//	                       'reason', a.reason,
//	                       'created_at', a.created_at
//	               )
//	        FROM products.product_audits a
//	        WHERE a.merchant_id = p.merchant_id
//	        ORDER BY a.created_at DESC
//	        LIMIT 1)                              AS latest_audit
//	FROM products.products p
//	         INNER JOIN products.inventory i
//	                    ON p.id = i.product_id AND p.merchant_id = i.merchant_id
//	         LEFT JOIN products.product_attributes pa
//	                   ON p.id = pa.product_id AND p.merchant_id = pa.merchant_id
//	WHERE p.merchant_id = $1
//	  AND p.deleted_at IS NULL
//	LIMIT $3 OFFSET $2
func (q *Queries) GetMerchantProducts(ctx context.Context, arg GetMerchantProductsParams) ([]GetMerchantProductsRow, error) {
	rows, err := q.db.Query(ctx, GetMerchantProducts, arg.MerchantID, arg.Page, arg.Pagesize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchantProductsRow
	for rows.Next() {
		var i GetMerchantProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Status,
			&i.MerchantID,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Stock,
			&i.Images,
			&i.Attributes,
			&i.LatestAudit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateProduct = `-- name: UpdateProduct :exec
UPDATE products.products
SET name        = coalesce($1, name),
    description = coalesce($2, description),
    price       = coalesce($3, price),
    updated_at  = now()
WHERE id = $4
  AND merchant_id = $5
`

type UpdateProductParams struct {
	Name        *string
	Description *string
	Price       pgtype.Numeric
	ID          pgtype.UUID
	MerchantID  pgtype.UUID
}

// UpdateProduct
//
//	UPDATE products.products
//	SET name        = coalesce($1, name),
//	    description = coalesce($2, description),
//	    price       = coalesce($3, price),
//	    updated_at  = now()
//	WHERE id = $4
//	  AND merchant_id = $5
func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.Exec(ctx, UpdateProduct,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.ID,
		arg.MerchantID,
	)
	return err
}
