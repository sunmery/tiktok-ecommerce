// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: order.sql

package models

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const ListOrdersByUser = `-- name: ListOrdersByUser :many
SELECT s.id,
       order_id,
       merchant_id,
       total_amount,
       s.currency,
       o.payment_status,
       s.shipping_status,
       items,
       s.created_at,
       s.updated_at
FROM orders.sub_orders s
         JOIN orders.orders o on s.order_id = o.id
WHERE merchant_id = $1
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type ListOrdersByUserParams struct {
	MerchantID pgtype.UUID
	Page       *int64
	PageSize   *int64
}

type ListOrdersByUserRow struct {
	ID             int64
	OrderID        int64
	MerchantID     uuid.UUID
	TotalAmount    interface{}
	Currency       string
	PaymentStatus  string
	ShippingStatus string
	Items          []byte
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

// ListOrdersByUser
//
//	SELECT s.id,
//	       order_id,
//	       merchant_id,
//	       total_amount,
//	       s.currency,
//	       o.payment_status,
//	       s.shipping_status,
//	       items,
//	       s.created_at,
//	       s.updated_at
//	FROM orders.sub_orders s
//	         JOIN orders.orders o on s.order_id = o.id
//	WHERE merchant_id = $1
//	ORDER BY created_at DESC
//	LIMIT $3 OFFSET $2
func (q *Queries) ListOrdersByUser(ctx context.Context, arg ListOrdersByUserParams) ([]ListOrdersByUserRow, error) {
	rows, err := q.db.Query(ctx, ListOrdersByUser, arg.MerchantID, arg.Page, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersByUserRow
	for rows.Next() {
		var i ListOrdersByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.MerchantID,
			&i.TotalAmount,
			&i.Currency,
			&i.PaymentStatus,
			&i.ShippingStatus,
			&i.Items,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const QuerySubOrders = `-- name: QuerySubOrders :many
SELECT s.order_id sub_orders_id,
       s.merchant_id,
       s.total_amount,
       s.currency,
       o.payment_status,
       s.shipping_status,
       s.items,
       s.created_at,
       s.updated_at
FROM orders.sub_orders s
         Join orders.orders o on s.order_id = o.id
WHERE order_id = $1
ORDER BY created_at
`

type QuerySubOrdersRow struct {
	SubOrdersID    int64
	MerchantID     uuid.UUID
	TotalAmount    interface{}
	Currency       string
	PaymentStatus  string
	ShippingStatus string
	Items          []byte
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

// QuerySubOrders
//
//	SELECT s.order_id sub_orders_id,
//	       s.merchant_id,
//	       s.total_amount,
//	       s.currency,
//	       o.payment_status,
//	       s.shipping_status,
//	       s.items,
//	       s.created_at,
//	       s.updated_at
//	FROM orders.sub_orders s
//	         Join orders.orders o on s.order_id = o.id
//	WHERE order_id = $1
//	ORDER BY created_at
func (q *Queries) QuerySubOrders(ctx context.Context, orderID *int64) ([]QuerySubOrdersRow, error) {
	rows, err := q.db.Query(ctx, QuerySubOrders, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QuerySubOrdersRow
	for rows.Next() {
		var i QuerySubOrdersRow
		if err := rows.Scan(
			&i.SubOrdersID,
			&i.MerchantID,
			&i.TotalAmount,
			&i.Currency,
			&i.PaymentStatus,
			&i.ShippingStatus,
			&i.Items,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
