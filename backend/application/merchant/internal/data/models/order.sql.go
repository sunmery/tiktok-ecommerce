// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: order.sql

package models

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CreateShip = `-- name: CreateShip :one
INSERT INTO orders.shipping_info(id, merchant_id, sub_order_id, shipping_status, tracking_number, carrier, delivery,
                                 shipping_address, receiver_address, shipping_fee)
VALUES ($1, $2, $3, $4, $5, $6, $7,
        $8, $9, $10)
RETURNING id, created_at
`

type CreateShipParams struct {
	ID              *int64
	MerchantID      pgtype.UUID
	SubOrderID      *int64
	ShippingStatus  *string
	TrackingNumber  *string
	Carrier         *string
	Delivery        pgtype.Timestamptz
	ShippingAddress []byte
	ReceiverAddress []byte
	ShippingFee     pgtype.Numeric
}

type CreateShipRow struct {
	ID        int64
	CreatedAt time.Time
}

// 创建货运信息
//
//	INSERT INTO orders.shipping_info(id, merchant_id, sub_order_id, shipping_status, tracking_number, carrier, delivery,
//	                                 shipping_address, receiver_address, shipping_fee)
//	VALUES ($1, $2, $3, $4, $5, $6, $7,
//	        $8, $9, $10)
//	RETURNING id, created_at
func (q *Queries) CreateShip(ctx context.Context, arg CreateShipParams) (CreateShipRow, error) {
	row := q.db.QueryRow(ctx, CreateShip,
		arg.ID,
		arg.MerchantID,
		arg.SubOrderID,
		arg.ShippingStatus,
		arg.TrackingNumber,
		arg.Carrier,
		arg.Delivery,
		arg.ShippingAddress,
		arg.ReceiverAddress,
		arg.ShippingFee,
	)
	var i CreateShipRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const GetConsumerAddress = `-- name: GetConsumerAddress :one
SELECT o.id,
       user_id,
       street_address,
       city,
       state,
       country,
       zip_code,
       email,
       payment_status,
       s.created_at,
       s.updated_at,
       s.shipping_status
FROM orders.sub_orders s
         Join orders.orders o on s.order_id = o.id
WHERE s.id = $1
`

type GetConsumerAddressRow struct {
	ID             int64
	UserID         uuid.UUID
	StreetAddress  string
	City           string
	State          string
	Country        string
	ZipCode        string
	Email          string
	PaymentStatus  string
	CreatedAt      time.Time
	UpdatedAt      time.Time
	ShippingStatus string
}

// 通过子订单 ID 去查询主订单的地址, 因为用户可能下单多个商品, 分别属于不同商家, 但地址并不会变化
//
//	SELECT o.id,
//	       user_id,
//	       street_address,
//	       city,
//	       state,
//	       country,
//	       zip_code,
//	       email,
//	       payment_status,
//	       s.created_at,
//	       s.updated_at,
//	       s.shipping_status
//	FROM orders.sub_orders s
//	         Join orders.orders o on s.order_id = o.id
//	WHERE s.id = $1
func (q *Queries) GetConsumerAddress(ctx context.Context, id *int64) (GetConsumerAddressRow, error) {
	row := q.db.QueryRow(ctx, GetConsumerAddress, id)
	var i GetConsumerAddressRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StreetAddress,
		&i.City,
		&i.State,
		&i.Country,
		&i.ZipCode,
		&i.Email,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ShippingStatus,
	)
	return i, err
}

const GetMerchantByOrderId = `-- name: GetMerchantByOrderId :one
SELECT os.merchant_id
FROM orders.sub_orders os
         JOIN orders.orders o on os.order_id = o.id
WHERE o.id = $1
`

// GetMerchantByOrderId
//
//	SELECT os.merchant_id
//	FROM orders.sub_orders os
//	         JOIN orders.orders o on os.order_id = o.id
//	WHERE o.id = $1
func (q *Queries) GetMerchantByOrderId(ctx context.Context, id *int64) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, GetMerchantByOrderId, id)
	var merchant_id uuid.UUID
	err := row.Scan(&merchant_id)
	return merchant_id, err
}

const GetMerchantOrders = `-- name: GetMerchantOrders :many
SELECT os.order_id,
       oo.created_at,
       json_agg(
               item::jsonb ||
               jsonb_build_object(
                       'subOrderId', os.id,
                       'userId', oo.user_id,
                       'email', oo.email,
                       'totalAmount', os.total_amount,
                       'createdAt', os.created_at,
                       'updatedAt', os.updated_at,
                       'paymentStatus', os.status,
                       'shippingStatus', os.shipping_status,
                       'currency', oo.currency,
                       'address', json_build_object(
                               'streetAddress', oo.street_address,
                               'city', oo.city,
                               'state', oo.state,
                               'country', oo.country,
                               'zipCode', oo.zip_code
                                  )
               )
       ) AS items
FROM orders.sub_orders os
         JOIN orders.orders oo ON os.order_id = oo.id,
     json_array_elements(os.items::json) AS item
WHERE os.merchant_id = $1
GROUP BY os.order_id, os.merchant_id, oo.created_at
ORDER BY oo.created_at DESC
LIMIT $3 OFFSET $2
`

type GetMerchantOrdersParams struct {
	MerchantID pgtype.UUID
	Page       *int64
	PageSize   *int64
}

type GetMerchantOrdersRow struct {
	OrderID   int64
	CreatedAt time.Time
	Items     []byte
}

// GetMerchantOrders
//
//	SELECT os.order_id,
//	       oo.created_at,
//	       json_agg(
//	               item::jsonb ||
//	               jsonb_build_object(
//	                       'subOrderId', os.id,
//	                       'userId', oo.user_id,
//	                       'email', oo.email,
//	                       'totalAmount', os.total_amount,
//	                       'createdAt', os.created_at,
//	                       'updatedAt', os.updated_at,
//	                       'paymentStatus', os.status,
//	                       'shippingStatus', os.shipping_status,
//	                       'currency', oo.currency,
//	                       'address', json_build_object(
//	                               'streetAddress', oo.street_address,
//	                               'city', oo.city,
//	                               'state', oo.state,
//	                               'country', oo.country,
//	                               'zipCode', oo.zip_code
//	                                  )
//	               )
//	       ) AS items
//	FROM orders.sub_orders os
//	         JOIN orders.orders oo ON os.order_id = oo.id,
//	     json_array_elements(os.items::json) AS item
//	WHERE os.merchant_id = $1
//	GROUP BY os.order_id, os.merchant_id, oo.created_at
//	ORDER BY oo.created_at DESC
//	LIMIT $3 OFFSET $2
func (q *Queries) GetMerchantOrders(ctx context.Context, arg GetMerchantOrdersParams) ([]GetMerchantOrdersRow, error) {
	rows, err := q.db.Query(ctx, GetMerchantOrders, arg.MerchantID, arg.Page, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchantOrdersRow
	for rows.Next() {
		var i GetMerchantOrdersRow
		if err := rows.Scan(&i.OrderID, &i.CreatedAt, &i.Items); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateOrderShippingStatus = `-- name: UpdateOrderShippingStatus :one
WITH update_shipping_info_ship_status AS (
    UPDATE orders.shipping_info
        SET
            merchant_id = $3,
            shipping_status = $1,
            tracking_number = $4,
            carrier = $5,
            receiver_address = $6,
            shipping_address = $7,
            shipping_fee = $8,
            updated_at = now()
        WHERE sub_order_id = $2)
UPDATE orders.sub_orders
SET shipping_status = $1,
    updated_at      = now()
WHERE id = $2
RETURNING id, updated_at
`

type UpdateOrderShippingStatusParams struct {
	ShippingStatus  *string
	SubOrderID      *int64
	MerchantID      pgtype.UUID
	TrackingNumber  *string
	Carrier         *string
	ReceiverAddress []byte
	ShippingAddress []byte
	ShippingFee     pgtype.Numeric
}

type UpdateOrderShippingStatusRow struct {
	ID        int64
	UpdatedAt time.Time
}

// WITH update_shipping_info_ship_status AS (
//
//	UPDATE orders.shipping_info
//	    SET shipping_status = @shipping_status,
//	        updated_at = now()
//	    WHERE sub_order_id = @sub_order_id)
//
// UPDATE orders.sub_orders
// SET shipping_status = @shipping_status,
//
//	updated_at      = now()
//
// WHERE id = @sub_order_id;
//
//	WITH update_shipping_info_ship_status AS (
//	    UPDATE orders.shipping_info
//	        SET
//	            merchant_id = $3,
//	            shipping_status = $1,
//	            tracking_number = $4,
//	            carrier = $5,
//	            receiver_address = $6,
//	            shipping_address = $7,
//	            shipping_fee = $8,
//	            updated_at = now()
//	        WHERE sub_order_id = $2)
//	UPDATE orders.sub_orders
//	SET shipping_status = $1,
//	    updated_at      = now()
//	WHERE id = $2
//	RETURNING id, updated_at
func (q *Queries) UpdateOrderShippingStatus(ctx context.Context, arg UpdateOrderShippingStatusParams) (UpdateOrderShippingStatusRow, error) {
	row := q.db.QueryRow(ctx, UpdateOrderShippingStatus,
		arg.ShippingStatus,
		arg.SubOrderID,
		arg.MerchantID,
		arg.TrackingNumber,
		arg.Carrier,
		arg.ReceiverAddress,
		arg.ShippingAddress,
		arg.ShippingFee,
	)
	var i UpdateOrderShippingStatusRow
	err := row.Scan(&i.ID, &i.UpdatedAt)
	return i, err
}
