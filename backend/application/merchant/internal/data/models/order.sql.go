// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: order.sql

package models

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const ListOrdersByUser = `-- name: ListOrdersByUser :many
SELECT id,
       order_id,
       merchant_id,
       total_amount,
       currency,
       status,
       items,
       created_at,
       updated_at,
       payment_status
FROM orders.sub_orders
WHERE merchant_id = $1
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type ListOrdersByUserParams struct {
	MerchantID pgtype.UUID
	Page       *int64
	PageSize   *int64
}

type ListOrdersByUserRow struct {
	ID            int64
	OrderID       int64
	MerchantID    uuid.UUID
	TotalAmount   interface{}
	Currency      string
	Status        string
	Items         []byte
	CreatedAt     time.Time
	UpdatedAt     time.Time
	PaymentStatus string
}

// ListOrdersByUser
//
//	SELECT id,
//	       order_id,
//	       merchant_id,
//	       total_amount,
//	       currency,
//	       status,
//	       items,
//	       created_at,
//	       updated_at,
//	       payment_status
//	FROM orders.sub_orders
//	WHERE merchant_id = $1
//	ORDER BY created_at DESC
//	LIMIT $3 OFFSET $2
func (q *Queries) ListOrdersByUser(ctx context.Context, arg ListOrdersByUserParams) ([]ListOrdersByUserRow, error) {
	rows, err := q.db.Query(ctx, ListOrdersByUser, arg.MerchantID, arg.Page, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersByUserRow
	for rows.Next() {
		var i ListOrdersByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.MerchantID,
			&i.TotalAmount,
			&i.Currency,
			&i.Status,
			&i.Items,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PaymentStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const QuerySubOrders = `-- name: QuerySubOrders :many
SELECT id,
       merchant_id,
       total_amount,
       currency,
       status,
       items,
       created_at,
       updated_at
FROM orders.sub_orders
WHERE order_id = $1
ORDER BY created_at
`

type QuerySubOrdersRow struct {
	ID          int64
	MerchantID  uuid.UUID
	TotalAmount interface{}
	Currency    string
	Status      string
	Items       []byte
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

// QuerySubOrders
//
//	SELECT id,
//	       merchant_id,
//	       total_amount,
//	       currency,
//	       status,
//	       items,
//	       created_at,
//	       updated_at
//	FROM orders.sub_orders
//	WHERE order_id = $1
//	ORDER BY created_at
func (q *Queries) QuerySubOrders(ctx context.Context, orderID *int64) ([]QuerySubOrdersRow, error) {
	rows, err := q.db.Query(ctx, QuerySubOrders, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QuerySubOrdersRow
	for rows.Next() {
		var i QuerySubOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.TotalAmount,
			&i.Currency,
			&i.Status,
			&i.Items,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
