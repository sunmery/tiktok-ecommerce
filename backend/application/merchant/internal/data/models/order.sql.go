// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: order.sql

package models

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CreateShip = `-- name: CreateShip :one
INSERT INTO orders.shipping_info(id, merchant_id, sub_order_id, shipping_status, tracking_number, carrier, delivery,
                                 shipping_address, receiver_address, shipping_fee)
VALUES ($1, $2, $3, $4, $5, $6, $7,
        $8, $9, $10)
RETURNING id, created_at
`

type CreateShipParams struct {
	ID              *int64
	MerchantID      pgtype.UUID
	SubOrderID      *int64
	ShippingStatus  interface{}
	TrackingNumber  *string
	Carrier         *string
	Delivery        pgtype.Timestamptz
	ShippingAddress []byte
	ReceiverAddress []byte
	ShippingFee     pgtype.Numeric
}

type CreateShipRow struct {
	ID        int64
	CreatedAt time.Time
}

// CreateShip
//
//	INSERT INTO orders.shipping_info(id, merchant_id, sub_order_id, shipping_status, tracking_number, carrier, delivery,
//	                                 shipping_address, receiver_address, shipping_fee)
//	VALUES ($1, $2, $3, $4, $5, $6, $7,
//	        $8, $9, $10)
//	RETURNING id, created_at
func (q *Queries) CreateShip(ctx context.Context, arg CreateShipParams) (CreateShipRow, error) {
	row := q.db.QueryRow(ctx, CreateShip,
		arg.ID,
		arg.MerchantID,
		arg.SubOrderID,
		arg.ShippingStatus,
		arg.TrackingNumber,
		arg.Carrier,
		arg.Delivery,
		arg.ShippingAddress,
		arg.ReceiverAddress,
		arg.ShippingFee,
	)
	var i CreateShipRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const GetConsumerAddress = `-- name: GetConsumerAddress :one
SELECT o.id,
       user_id,
       street_address,
       city,
       state,
       country,
       zip_code,
       email,
       payment_status,
       s.created_at,
       s.updated_at,
       s.shipping_status
FROM orders.sub_orders s
         Join orders.orders o on s.order_id = o.id
WHERE s.id = $1
`

type GetConsumerAddressRow struct {
	ID             int64
	UserID         uuid.UUID
	StreetAddress  string
	City           string
	State          string
	Country        string
	ZipCode        string
	Email          string
	PaymentStatus  interface{}
	CreatedAt      time.Time
	UpdatedAt      time.Time
	ShippingStatus interface{}
}

// 通过子订单 ID 去查询主订单的地址, 因为用户可能下单多个商品, 分别属于不同商家, 但地址并不会变化
//
//	SELECT o.id,
//	       user_id,
//	       street_address,
//	       city,
//	       state,
//	       country,
//	       zip_code,
//	       email,
//	       payment_status,
//	       s.created_at,
//	       s.updated_at,
//	       s.shipping_status
//	FROM orders.sub_orders s
//	         Join orders.orders o on s.order_id = o.id
//	WHERE s.id = $1
func (q *Queries) GetConsumerAddress(ctx context.Context, id *int64) (GetConsumerAddressRow, error) {
	row := q.db.QueryRow(ctx, GetConsumerAddress, id)
	var i GetConsumerAddressRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StreetAddress,
		&i.City,
		&i.State,
		&i.Country,
		&i.ZipCode,
		&i.Email,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ShippingStatus,
	)
	return i, err
}

const ListOrdersByUser = `-- name: ListOrdersByUser :many
SELECT oo.id AS order_id,
       os.merchant_id,
       total_amount,
       os.currency,
       os.shipping_status,
       oo.payment_status,
       si.sub_order_id,
       si.tracking_number,
       si.carrier,
       si.shipping_status,
       si.delivery,
       si.shipping_address,
       si.receiver_address,
       si.shipping_fee,
       si.created_at,
       items
FROM orders.sub_orders os
         JOIN orders.orders oo on os.order_id = oo.id
         LEFT JOIN orders.shipping_info si on os.id = si.sub_order_id
WHERE os.merchant_id = $1
ORDER BY si.created_at DESC
LIMIT $3 OFFSET $2
`

type ListOrdersByUserParams struct {
	MerchantID pgtype.UUID
	Page       *int64
	PageSize   *int64
}

type ListOrdersByUserRow struct {
	OrderID          int64
	MerchantID       uuid.UUID
	TotalAmount      interface{}
	Currency         string
	ShippingStatus   interface{}
	PaymentStatus    interface{}
	SubOrderID       int64
	TrackingNumber   string
	Carrier          string
	ShippingStatus_2 interface{}
	Delivery         time.Time
	ShippingAddress  []byte
	ReceiverAddress  []byte
	ShippingFee      interface{}
	CreatedAt        time.Time
	Items            []byte
}

// ListOrdersByUser
//
//	SELECT oo.id AS order_id,
//	       os.merchant_id,
//	       total_amount,
//	       os.currency,
//	       os.shipping_status,
//	       oo.payment_status,
//	       si.sub_order_id,
//	       si.tracking_number,
//	       si.carrier,
//	       si.shipping_status,
//	       si.delivery,
//	       si.shipping_address,
//	       si.receiver_address,
//	       si.shipping_fee,
//	       si.created_at,
//	       items
//	FROM orders.sub_orders os
//	         JOIN orders.orders oo on os.order_id = oo.id
//	         LEFT JOIN orders.shipping_info si on os.id = si.sub_order_id
//	WHERE os.merchant_id = $1
//	ORDER BY si.created_at DESC
//	LIMIT $3 OFFSET $2
func (q *Queries) ListOrdersByUser(ctx context.Context, arg ListOrdersByUserParams) ([]ListOrdersByUserRow, error) {
	rows, err := q.db.Query(ctx, ListOrdersByUser, arg.MerchantID, arg.Page, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersByUserRow
	for rows.Next() {
		var i ListOrdersByUserRow
		if err := rows.Scan(
			&i.OrderID,
			&i.MerchantID,
			&i.TotalAmount,
			&i.Currency,
			&i.ShippingStatus,
			&i.PaymentStatus,
			&i.SubOrderID,
			&i.TrackingNumber,
			&i.Carrier,
			&i.ShippingStatus_2,
			&i.Delivery,
			&i.ShippingAddress,
			&i.ReceiverAddress,
			&i.ShippingFee,
			&i.CreatedAt,
			&i.Items,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const QuerySubOrders = `-- name: QuerySubOrders :many
SELECT os.id AS sub_order_id,
       merchant_id,
       total_amount,
       oo.currency,
       status,
       items,
       oo.created_at,
       oo.updated_at,
       oo.payment_status,
       os.shipping_status
FROM orders.sub_orders os
         Join orders.orders oo on os.order_id = oo.id
WHERE order_id = $1
ORDER BY created_at
`

type QuerySubOrdersRow struct {
	SubOrderID     int64
	MerchantID     uuid.UUID
	TotalAmount    interface{}
	Currency       string
	Status         string
	Items          []byte
	CreatedAt      time.Time
	UpdatedAt      time.Time
	PaymentStatus  interface{}
	ShippingStatus interface{}
}

// QuerySubOrders
//
//	SELECT os.id AS sub_order_id,
//	       merchant_id,
//	       total_amount,
//	       oo.currency,
//	       status,
//	       items,
//	       oo.created_at,
//	       oo.updated_at,
//	       oo.payment_status,
//	       os.shipping_status
//	FROM orders.sub_orders os
//	         Join orders.orders oo on os.order_id = oo.id
//	WHERE order_id = $1
//	ORDER BY created_at
func (q *Queries) QuerySubOrders(ctx context.Context, orderID *int64) ([]QuerySubOrdersRow, error) {
	rows, err := q.db.Query(ctx, QuerySubOrders, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QuerySubOrdersRow
	for rows.Next() {
		var i QuerySubOrdersRow
		if err := rows.Scan(
			&i.SubOrderID,
			&i.MerchantID,
			&i.TotalAmount,
			&i.Currency,
			&i.Status,
			&i.Items,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PaymentStatus,
			&i.ShippingStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
