// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: order.sql

package models

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CreateShip = `-- name: CreateShip :one
INSERT INTO orders.shipping_info(id, merchant_id, sub_order_id, shipping_status, tracking_number, carrier, delivery,
                                 shipping_address, receiver_address, shipping_fee)
VALUES ($1, $2, $3, $4, $5, $6, $7,
        $8, $9, $10)
RETURNING id, created_at
`

type CreateShipParams struct {
	ID              *int64
	MerchantID      pgtype.UUID
	SubOrderID      *int64
	ShippingStatus  *string
	TrackingNumber  *string
	Carrier         *string
	Delivery        pgtype.Timestamptz
	ShippingAddress []byte
	ReceiverAddress []byte
	ShippingFee     pgtype.Numeric
}

type CreateShipRow struct {
	ID        int64
	CreatedAt time.Time
}

// CreateShip
//
//	INSERT INTO orders.shipping_info(id, merchant_id, sub_order_id, shipping_status, tracking_number, carrier, delivery,
//	                                 shipping_address, receiver_address, shipping_fee)
//	VALUES ($1, $2, $3, $4, $5, $6, $7,
//	        $8, $9, $10)
//	RETURNING id, created_at
func (q *Queries) CreateShip(ctx context.Context, arg CreateShipParams) (CreateShipRow, error) {
	row := q.db.QueryRow(ctx, CreateShip,
		arg.ID,
		arg.MerchantID,
		arg.SubOrderID,
		arg.ShippingStatus,
		arg.TrackingNumber,
		arg.Carrier,
		arg.Delivery,
		arg.ShippingAddress,
		arg.ReceiverAddress,
		arg.ShippingFee,
	)
	var i CreateShipRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const GetConsumerAddress = `-- name: GetConsumerAddress :one
SELECT o.id,
       user_id,
       street_address,
       city,
       state,
       country,
       zip_code,
       email,
       payment_status,
       s.created_at,
       s.updated_at,
       s.shipping_status
FROM orders.sub_orders s
         Join orders.orders o on s.order_id = o.id
WHERE s.id = $1
`

type GetConsumerAddressRow struct {
	ID             int64
	UserID         uuid.UUID
	StreetAddress  string
	City           string
	State          string
	Country        string
	ZipCode        string
	Email          string
	PaymentStatus  string
	CreatedAt      time.Time
	UpdatedAt      time.Time
	ShippingStatus string
}

// 通过子订单 ID 去查询主订单的地址, 因为用户可能下单多个商品, 分别属于不同商家, 但地址并不会变化
//
//	SELECT o.id,
//	       user_id,
//	       street_address,
//	       city,
//	       state,
//	       country,
//	       zip_code,
//	       email,
//	       payment_status,
//	       s.created_at,
//	       s.updated_at,
//	       s.shipping_status
//	FROM orders.sub_orders s
//	         Join orders.orders o on s.order_id = o.id
//	WHERE s.id = $1
func (q *Queries) GetConsumerAddress(ctx context.Context, id *int64) (GetConsumerAddressRow, error) {
	row := q.db.QueryRow(ctx, GetConsumerAddress, id)
	var i GetConsumerAddressRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StreetAddress,
		&i.City,
		&i.State,
		&i.Country,
		&i.ZipCode,
		&i.Email,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ShippingStatus,
	)
	return i, err
}

const GetMerchantByOrderId = `-- name: GetMerchantByOrderId :one
SELECT os.merchant_id
FROM orders.sub_orders os
         JOIN orders.orders o on os.order_id = o.id
WHERE o.id = $1
`

// GetMerchantByOrderId
//
//	SELECT os.merchant_id
//	FROM orders.sub_orders os
//	         JOIN orders.orders o on os.order_id = o.id
//	WHERE o.id = $1
func (q *Queries) GetMerchantByOrderId(ctx context.Context, id *int64) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, GetMerchantByOrderId, id)
	var merchant_id uuid.UUID
	err := row.Scan(&merchant_id)
	return merchant_id, err
}

const GetMerchantOrders = `-- name: GetMerchantOrders :many
SELECT oo.id,
       oo.payment_status,
       oo.user_id,
       oo.currency,
       oo.street_address,
       oo.city,
       oo.state,
       oo.country,
       oo.zip_code,
       oo.email,
       os.order_id        AS order_id,
       os.merchant_id,
       os.total_amount,
       os.items,
       os.shipping_status AS shipping_status,
       os.created_at,
       os.updated_at
FROM orders.sub_orders os
         JOIN orders.orders oo on os.order_id = oo.id
WHERE os.merchant_id = $1
ORDER BY os.created_at DESC
LIMIT $3 OFFSET $2
`

type GetMerchantOrdersParams struct {
	MerchantID pgtype.UUID
	Page       *int64
	PageSize   *int64
}

type GetMerchantOrdersRow struct {
	ID             int64
	PaymentStatus  string
	UserID         uuid.UUID
	Currency       string
	StreetAddress  string
	City           string
	State          string
	Country        string
	ZipCode        string
	Email          string
	OrderID        int64
	MerchantID     uuid.UUID
	TotalAmount    interface{}
	Items          []byte
	ShippingStatus string
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

// GetMerchantOrders
//
//	SELECT oo.id,
//	       oo.payment_status,
//	       oo.user_id,
//	       oo.currency,
//	       oo.street_address,
//	       oo.city,
//	       oo.state,
//	       oo.country,
//	       oo.zip_code,
//	       oo.email,
//	       os.order_id        AS order_id,
//	       os.merchant_id,
//	       os.total_amount,
//	       os.items,
//	       os.shipping_status AS shipping_status,
//	       os.created_at,
//	       os.updated_at
//	FROM orders.sub_orders os
//	         JOIN orders.orders oo on os.order_id = oo.id
//	WHERE os.merchant_id = $1
//	ORDER BY os.created_at DESC
//	LIMIT $3 OFFSET $2
func (q *Queries) GetMerchantOrders(ctx context.Context, arg GetMerchantOrdersParams) ([]GetMerchantOrdersRow, error) {
	rows, err := q.db.Query(ctx, GetMerchantOrders, arg.MerchantID, arg.Page, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchantOrdersRow
	for rows.Next() {
		var i GetMerchantOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.PaymentStatus,
			&i.UserID,
			&i.Currency,
			&i.StreetAddress,
			&i.City,
			&i.State,
			&i.Country,
			&i.ZipCode,
			&i.Email,
			&i.OrderID,
			&i.MerchantID,
			&i.TotalAmount,
			&i.Items,
			&i.ShippingStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateOrderShippingStatus = `-- name: UpdateOrderShippingStatus :exec
WITH update_shipping_info_ship_status AS (
    UPDATE orders.shipping_info
        SET shipping_status = $1,
            updated_at = now()
        WHERE sub_order_id = $2)
UPDATE orders.sub_orders
SET shipping_status = $1,
    updated_at      = now()
WHERE id = $2
`

type UpdateOrderShippingStatusParams struct {
	ShippingStatus *string
	SubOrderID     *int64
}

// UpdateOrderShippingStatus
//
//	WITH update_shipping_info_ship_status AS (
//	    UPDATE orders.shipping_info
//	        SET shipping_status = $1,
//	            updated_at = now()
//	        WHERE sub_order_id = $2)
//	UPDATE orders.sub_orders
//	SET shipping_status = $1,
//	    updated_at      = now()
//	WHERE id = $2
func (q *Queries) UpdateOrderShippingStatus(ctx context.Context, arg UpdateOrderShippingStatusParams) error {
	_, err := q.db.Exec(ctx, UpdateOrderShippingStatus, arg.ShippingStatus, arg.SubOrderID)
	return err
}
