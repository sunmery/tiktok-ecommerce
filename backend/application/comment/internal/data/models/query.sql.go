// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package models

import (
	"context"

	"github.com/google/uuid"
)

const CreateComment = `-- name: CreateComment :one
WITH check_sensitive_word AS (
    -- 检查 content 是否包含敏感词
    SELECT EXISTS (SELECT 1
                   FROM admin.sensitive_words sw
                   WHERE $1::text ILIKE '%' || sw.word || '%'
                     AND sw.is_active = TRUE) AS has_sensitive_word),
     insert_comment AS (
         -- 如果没有检测到敏感词，则执行插入操作
         INSERT INTO comments.comments (id, product_id, merchant_id, user_id, score, content)
             SELECT $2::bigint, $3::uuid, $4::uuid, $5::uuid, $6, $1
             WHERE NOT (SELECT has_sensitive_word FROM check_sensitive_word)
             RETURNING id, product_id, merchant_id, user_id, score, content, created_at, updated_at)
SELECT has_sensitive_word AS is_sensitive
FROM check_sensitive_word
`

type CreateCommentParams struct {
	Content    string    `json:"content"`
	ID         int64     `json:"id"`
	ProductID  uuid.UUID `json:"productID"`
	MerchantID uuid.UUID `json:"merchantID"`
	UserID     uuid.UUID `json:"userID"`
	Score      int32     `json:"score"`
}

// 返回最终结果：是否命中敏感词
//
//	WITH check_sensitive_word AS (
//	    -- 检查 content 是否包含敏感词
//	    SELECT EXISTS (SELECT 1
//	                   FROM admin.sensitive_words sw
//	                   WHERE $1::text ILIKE '%' || sw.word || '%'
//	                     AND sw.is_active = TRUE) AS has_sensitive_word),
//	     insert_comment AS (
//	         -- 如果没有检测到敏感词，则执行插入操作
//	         INSERT INTO comments.comments (id, product_id, merchant_id, user_id, score, content)
//	             SELECT $2::bigint, $3::uuid, $4::uuid, $5::uuid, $6, $1
//	             WHERE NOT (SELECT has_sensitive_word FROM check_sensitive_word)
//	             RETURNING id, product_id, merchant_id, user_id, score, content, created_at, updated_at)
//	SELECT has_sensitive_word AS is_sensitive
//	FROM check_sensitive_word
func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (bool, error) {
	row := q.db.QueryRow(ctx, CreateComment,
		arg.Content,
		arg.ID,
		arg.ProductID,
		arg.MerchantID,
		arg.UserID,
		arg.Score,
	)
	var is_sensitive bool
	err := row.Scan(&is_sensitive)
	return is_sensitive, err
}

const DeleteComment = `-- name: DeleteComment :exec
DELETE
FROM comments.comments
WHERE id = $1
  AND user_id = $2
`

type DeleteCommentParams struct {
	ID     int64     `json:"id"`
	UserID uuid.UUID `json:"userID"`
}

// DeleteComment
//
//	DELETE
//	FROM comments.comments
//	WHERE id = $1
//	  AND user_id = $2
func (q *Queries) DeleteComment(ctx context.Context, arg DeleteCommentParams) error {
	_, err := q.db.Exec(ctx, DeleteComment, arg.ID, arg.UserID)
	return err
}

const GetCommentCount = `-- name: GetCommentCount :one
SELECT COUNT(*)
FROM comments.comments
WHERE product_id = $1
  AND merchant_id = $2
`

type GetCommentCountParams struct {
	ProductID  uuid.UUID `json:"productID"`
	MerchantID uuid.UUID `json:"merchantID"`
}

// GetCommentCount
//
//	SELECT COUNT(*)
//	FROM comments.comments
//	WHERE product_id = $1
//	  AND merchant_id = $2
func (q *Queries) GetCommentCount(ctx context.Context, arg GetCommentCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, GetCommentCount, arg.ProductID, arg.MerchantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetCommentsByProduct = `-- name: GetCommentsByProduct :many
SELECT id, product_id, merchant_id, user_id, score, content, created_at, updated_at
FROM comments.comments
WHERE product_id = $1
  AND merchant_id = $2
ORDER BY created_at DESC
LIMIT $4 OFFSET $3
`

type GetCommentsByProductParams struct {
	ProductID  uuid.UUID `json:"productID"`
	MerchantID uuid.UUID `json:"merchantID"`
	Page       int64     `json:"page"`
	PageSize   int64     `json:"pageSize"`
}

// GetCommentsByProduct
//
//	SELECT id, product_id, merchant_id, user_id, score, content, created_at, updated_at
//	FROM comments.comments
//	WHERE product_id = $1
//	  AND merchant_id = $2
//	ORDER BY created_at DESC
//	LIMIT $4 OFFSET $3
func (q *Queries) GetCommentsByProduct(ctx context.Context, arg GetCommentsByProductParams) ([]CommentsComments, error) {
	rows, err := q.db.Query(ctx, GetCommentsByProduct,
		arg.ProductID,
		arg.MerchantID,
		arg.Page,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CommentsComments
	for rows.Next() {
		var i CommentsComments
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.MerchantID,
			&i.UserID,
			&i.Score,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateComment = `-- name: UpdateComment :one
UPDATE comments.comments
SET score      = COALESCE($1, score),
    content    = COALESCE($2, content),
    updated_at = NOW()
WHERE id = $3
  AND user_id = $4
RETURNING id, product_id, merchant_id, user_id, score, content, created_at, updated_at
`

type UpdateCommentParams struct {
	Score   int32     `json:"score"`
	Content string    `json:"content"`
	ID      int64     `json:"id"`
	UserID  uuid.UUID `json:"userID"`
}

// UpdateComment
//
//	UPDATE comments.comments
//	SET score      = COALESCE($1, score),
//	    content    = COALESCE($2, content),
//	    updated_at = NOW()
//	WHERE id = $3
//	  AND user_id = $4
//	RETURNING id, product_id, merchant_id, user_id, score, content, created_at, updated_at
func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (CommentsComments, error) {
	row := q.db.QueryRow(ctx, UpdateComment,
		arg.Score,
		arg.Content,
		arg.ID,
		arg.UserID,
	)
	var i CommentsComments
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.MerchantID,
		&i.UserID,
		&i.Score,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
