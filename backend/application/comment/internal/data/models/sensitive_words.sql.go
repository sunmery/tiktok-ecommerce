// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sensitive_words.sql

package models

import (
	"context"

	"github.com/google/uuid"
)

const DeleteSensitiveWord = `-- name: DeleteSensitiveWord :exec
DELETE
FROM admin.sensitive_words
WHERE id = $1
  AND created_by = $2::uuid
`

type DeleteSensitiveWordParams struct {
	ID        int32     `json:"id"`
	CreatedBy uuid.UUID `json:"createdBy"`
}

// DeleteSensitiveWord
//
//	DELETE
//	FROM admin.sensitive_words
//	WHERE id = $1
//	  AND created_by = $2::uuid
func (q *Queries) DeleteSensitiveWord(ctx context.Context, arg DeleteSensitiveWordParams) error {
	_, err := q.db.Exec(ctx, DeleteSensitiveWord, arg.ID, arg.CreatedBy)
	return err
}

const GetSensitiveWordByID = `-- name: GetSensitiveWordByID :one
SELECT id, created_by, category, word, level, is_active, created_at, updated_at
FROM admin.sensitive_words
WHERE id = $1
`

// GetSensitiveWordByID
//
//	SELECT id, created_by, category, word, level, is_active, created_at, updated_at
//	FROM admin.sensitive_words
//	WHERE id = $1
func (q *Queries) GetSensitiveWordByID(ctx context.Context, id int32) (AdminSensitiveWords, error) {
	row := q.db.QueryRow(ctx, GetSensitiveWordByID, id)
	var i AdminSensitiveWords
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.Category,
		&i.Word,
		&i.Level,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSensitiveWords = `-- name: GetSensitiveWords :many
SELECT id, created_by, category, word, level, is_active, created_at, updated_at
FROM admin.sensitive_words
WHERE ($1::uuid IS NULL OR created_by = $1::uuid)
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type GetSensitiveWordsParams struct {
	CreatedBy uuid.UUID `json:"createdBy"`
	Page      int64     `json:"page"`
	PageSize  int64     `json:"pageSize"`
}

// GetSensitiveWords
//
//	SELECT id, created_by, category, word, level, is_active, created_at, updated_at
//	FROM admin.sensitive_words
//	WHERE ($1::uuid IS NULL OR created_by = $1::uuid)
//	ORDER BY created_at DESC
//	LIMIT $3 OFFSET $2
func (q *Queries) GetSensitiveWords(ctx context.Context, arg GetSensitiveWordsParams) ([]AdminSensitiveWords, error) {
	rows, err := q.db.Query(ctx, GetSensitiveWords, arg.CreatedBy, arg.Page, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminSensitiveWords
	for rows.Next() {
		var i AdminSensitiveWords
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.Category,
			&i.Word,
			&i.Level,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SetSensitiveWords = `-- name: SetSensitiveWords :execrows
INSERT INTO admin.sensitive_words (created_by, category, word, level, is_active)
VALUES ($1::uuid, $2, $3, $4, $5)
ON CONFLICT (word) DO UPDATE
    SET category   = EXCLUDED.category,
        level     = EXCLUDED.level,
        is_active = EXCLUDED.is_active,
        updated_at = NOW()
`

type SetSensitiveWordsParams struct {
	CreatedBy uuid.UUID `json:"createdBy"`
	Category  string    `json:"category"`
	Word      string    `json:"word"`
	Level     int32     `json:"level"`
	IsActive  bool      `json:"isActive"`
}

// SetSensitiveWords
//
//	INSERT INTO admin.sensitive_words (created_by, category, word, level, is_active)
//	VALUES ($1::uuid, $2, $3, $4, $5)
//	ON CONFLICT (word) DO UPDATE
//	    SET category   = EXCLUDED.category,
//	        level     = EXCLUDED.level,
//	        is_active = EXCLUDED.is_active,
//	        updated_at = NOW()
func (q *Queries) SetSensitiveWords(ctx context.Context, arg SetSensitiveWordsParams) (int64, error) {
	result, err := q.db.Exec(ctx, SetSensitiveWords,
		arg.CreatedBy,
		arg.Category,
		arg.Word,
		arg.Level,
		arg.IsActive,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
