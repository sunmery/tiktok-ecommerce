// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.4
// - protoc             v5.29.3
// source: v1/balance.proto

package balancev1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationBalanceCancelFreeze = "/ecommerce.balance.v1.Balance/CancelFreeze"
const OperationBalanceConfirmTransfer = "/ecommerce.balance.v1.Balance/ConfirmTransfer"
const OperationBalanceCreateConsumersBalance = "/ecommerce.balance.v1.Balance/CreateConsumersBalance"
const OperationBalanceCreateMerchantBalance = "/ecommerce.balance.v1.Balance/CreateMerchantBalance"
const OperationBalanceCreateTransaction = "/ecommerce.balance.v1.Balance/CreateTransaction"
const OperationBalanceFreezeBalance = "/ecommerce.balance.v1.Balance/FreezeBalance"
const OperationBalanceGetMerchantBalance = "/ecommerce.balance.v1.Balance/GetMerchantBalance"
const OperationBalanceGetMerchantVersion = "/ecommerce.balance.v1.Balance/GetMerchantVersion"
const OperationBalanceGetTransactions = "/ecommerce.balance.v1.Balance/GetTransactions"
const OperationBalanceGetUserBalance = "/ecommerce.balance.v1.Balance/GetUserBalance"
const OperationBalanceRechargeBalance = "/ecommerce.balance.v1.Balance/RechargeBalance"
const OperationBalanceRechargeMerchantBalance = "/ecommerce.balance.v1.Balance/RechargeMerchantBalance"
const OperationBalanceWithdrawBalance = "/ecommerce.balance.v1.Balance/WithdrawBalance"

type BalanceHTTPServer interface {
	// CancelFreeze 取消冻结
	CancelFreeze(context.Context, *CancelFreezeRequest) (*CancelFreezeReply, error)
	// ConfirmTransfer 确认转账（解冻并转给商家）
	ConfirmTransfer(context.Context, *ConfirmTransferRequest) (*ConfirmTransferReply, error)
	// CreateConsumersBalance 创建消费者账号指定币种的初始余额记录
	CreateConsumersBalance(context.Context, *CreateConsumersBalanceRequest) (*CreateConsumersBalanceReply, error)
	// CreateMerchantBalance 创建商家账号指定币种的初始余额记录
	CreateMerchantBalance(context.Context, *CreateMerchantBalanceRequest) (*CreateMerchantBalanceReply, error)
	// CreateTransaction 创建订单流水
	CreateTransaction(context.Context, *CreateTransactionRequest) (*CreateTransactionReply, error)
	// FreezeBalance 冻结用户余额
	FreezeBalance(context.Context, *FreezeBalanceRequest) (*FreezeBalanceReply, error)
	// GetMerchantBalance 获取商家余额
	GetMerchantBalance(context.Context, *GetMerchantBalanceRequest) (*BalanceReply, error)
	// GetMerchantVersion 获取商家版本号
	GetMerchantVersion(context.Context, *GetMerchantVersionRequest) (*GetMerchantVersionReply, error)
	// GetTransactions 获取商家或者用户订单流水
	GetTransactions(context.Context, *GetTransactionsRequest) (*GetTransactionsReply, error)
	// GetUserBalance 获取用户余额
	GetUserBalance(context.Context, *GetUserBalanceRequest) (*BalanceReply, error)
	// RechargeBalance 用户余额充值
	RechargeBalance(context.Context, *RechargeBalanceRequest) (*RechargeBalanceReply, error)
	// RechargeMerchantBalance 商家余额充值
	RechargeMerchantBalance(context.Context, *RechargeMerchantBalanceRequest) (*RechargeMerchantBalanceReply, error)
	// WithdrawBalance 用户提现
	WithdrawBalance(context.Context, *WithdrawBalanceRequest) (*WithdrawBalanceReply, error)
}

func RegisterBalanceHTTPServer(s *http.Server, srv BalanceHTTPServer) {
	r := s.Route("/")
	r.PUT("/v1/balances/merchants/{merchant_id}/balance", _Balance_CreateMerchantBalance0_HTTP_Handler(srv))
	r.GET("/v1/orders/merchant/version", _Balance_GetMerchantVersion0_HTTP_Handler(srv))
	r.GET("/v1/balances/transactions", _Balance_GetTransactions0_HTTP_Handler(srv))
	r.GET("/v1/balances/merchants/{merchant_id}/balance", _Balance_GetMerchantBalance0_HTTP_Handler(srv))
	r.PUT("/v1/balances/consumers/{user_id}/balance", _Balance_CreateConsumersBalance0_HTTP_Handler(srv))
	r.POST("/v1/balances/consumers/recharge", _Balance_RechargeBalance0_HTTP_Handler(srv))
	r.GET("/v1/balances/consumers/balance", _Balance_GetUserBalance0_HTTP_Handler(srv))
	r.POST("/v1/balances/freeze", _Balance_FreezeBalance0_HTTP_Handler(srv))
	r.POST("/v1/balances/freezes/{freeze_id}/cancel", _Balance_CancelFreeze0_HTTP_Handler(srv))
	r.POST("/v1/balances/freezes/{freeze_id}/confirm", _Balance_ConfirmTransfer0_HTTP_Handler(srv))
	r.POST("/v1/balances/consumers/withdraw", _Balance_WithdrawBalance0_HTTP_Handler(srv))
	r.PUT("/v1/balances/transactions", _Balance_CreateTransaction0_HTTP_Handler(srv))
	r.POST("/v1/balances/merchants/recharge", _Balance_RechargeMerchantBalance0_HTTP_Handler(srv))
}

func _Balance_CreateMerchantBalance0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateMerchantBalanceRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceCreateMerchantBalance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateMerchantBalance(ctx, req.(*CreateMerchantBalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateMerchantBalanceReply)
		return ctx.Result(200, reply)
	}
}

func _Balance_GetMerchantVersion0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetMerchantVersionRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceGetMerchantVersion)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetMerchantVersion(ctx, req.(*GetMerchantVersionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetMerchantVersionReply)
		return ctx.Result(200, reply)
	}
}

func _Balance_GetTransactions0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetTransactionsRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceGetTransactions)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetTransactions(ctx, req.(*GetTransactionsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetTransactionsReply)
		return ctx.Result(200, reply)
	}
}

func _Balance_GetMerchantBalance0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetMerchantBalanceRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceGetMerchantBalance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetMerchantBalance(ctx, req.(*GetMerchantBalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BalanceReply)
		return ctx.Result(200, reply)
	}
}

func _Balance_CreateConsumersBalance0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateConsumersBalanceRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceCreateConsumersBalance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateConsumersBalance(ctx, req.(*CreateConsumersBalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateConsumersBalanceReply)
		return ctx.Result(200, reply)
	}
}

func _Balance_RechargeBalance0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RechargeBalanceRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceRechargeBalance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RechargeBalance(ctx, req.(*RechargeBalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RechargeBalanceReply)
		return ctx.Result(200, reply)
	}
}

func _Balance_GetUserBalance0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetUserBalanceRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceGetUserBalance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetUserBalance(ctx, req.(*GetUserBalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BalanceReply)
		return ctx.Result(200, reply)
	}
}

func _Balance_FreezeBalance0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in FreezeBalanceRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceFreezeBalance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.FreezeBalance(ctx, req.(*FreezeBalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*FreezeBalanceReply)
		return ctx.Result(200, reply)
	}
}

func _Balance_CancelFreeze0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CancelFreezeRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceCancelFreeze)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CancelFreeze(ctx, req.(*CancelFreezeRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CancelFreezeReply)
		return ctx.Result(200, reply)
	}
}

func _Balance_ConfirmTransfer0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ConfirmTransferRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceConfirmTransfer)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ConfirmTransfer(ctx, req.(*ConfirmTransferRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ConfirmTransferReply)
		return ctx.Result(200, reply)
	}
}

func _Balance_WithdrawBalance0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in WithdrawBalanceRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceWithdrawBalance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.WithdrawBalance(ctx, req.(*WithdrawBalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*WithdrawBalanceReply)
		return ctx.Result(200, reply)
	}
}

func _Balance_CreateTransaction0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateTransactionRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceCreateTransaction)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateTransaction(ctx, req.(*CreateTransactionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateTransactionReply)
		return ctx.Result(200, reply)
	}
}

func _Balance_RechargeMerchantBalance0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RechargeMerchantBalanceRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceRechargeMerchantBalance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RechargeMerchantBalance(ctx, req.(*RechargeMerchantBalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RechargeMerchantBalanceReply)
		return ctx.Result(200, reply)
	}
}

type BalanceHTTPClient interface {
	CancelFreeze(ctx context.Context, req *CancelFreezeRequest, opts ...http.CallOption) (rsp *CancelFreezeReply, err error)
	ConfirmTransfer(ctx context.Context, req *ConfirmTransferRequest, opts ...http.CallOption) (rsp *ConfirmTransferReply, err error)
	CreateConsumersBalance(ctx context.Context, req *CreateConsumersBalanceRequest, opts ...http.CallOption) (rsp *CreateConsumersBalanceReply, err error)
	CreateMerchantBalance(ctx context.Context, req *CreateMerchantBalanceRequest, opts ...http.CallOption) (rsp *CreateMerchantBalanceReply, err error)
	CreateTransaction(ctx context.Context, req *CreateTransactionRequest, opts ...http.CallOption) (rsp *CreateTransactionReply, err error)
	FreezeBalance(ctx context.Context, req *FreezeBalanceRequest, opts ...http.CallOption) (rsp *FreezeBalanceReply, err error)
	GetMerchantBalance(ctx context.Context, req *GetMerchantBalanceRequest, opts ...http.CallOption) (rsp *BalanceReply, err error)
	GetMerchantVersion(ctx context.Context, req *GetMerchantVersionRequest, opts ...http.CallOption) (rsp *GetMerchantVersionReply, err error)
	GetTransactions(ctx context.Context, req *GetTransactionsRequest, opts ...http.CallOption) (rsp *GetTransactionsReply, err error)
	GetUserBalance(ctx context.Context, req *GetUserBalanceRequest, opts ...http.CallOption) (rsp *BalanceReply, err error)
	RechargeBalance(ctx context.Context, req *RechargeBalanceRequest, opts ...http.CallOption) (rsp *RechargeBalanceReply, err error)
	RechargeMerchantBalance(ctx context.Context, req *RechargeMerchantBalanceRequest, opts ...http.CallOption) (rsp *RechargeMerchantBalanceReply, err error)
	WithdrawBalance(ctx context.Context, req *WithdrawBalanceRequest, opts ...http.CallOption) (rsp *WithdrawBalanceReply, err error)
}

type BalanceHTTPClientImpl struct {
	cc *http.Client
}

func NewBalanceHTTPClient(client *http.Client) BalanceHTTPClient {
	return &BalanceHTTPClientImpl{client}
}

func (c *BalanceHTTPClientImpl) CancelFreeze(ctx context.Context, in *CancelFreezeRequest, opts ...http.CallOption) (*CancelFreezeReply, error) {
	var out CancelFreezeReply
	pattern := "/v1/balances/freezes/{freeze_id}/cancel"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBalanceCancelFreeze))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) ConfirmTransfer(ctx context.Context, in *ConfirmTransferRequest, opts ...http.CallOption) (*ConfirmTransferReply, error) {
	var out ConfirmTransferReply
	pattern := "/v1/balances/freezes/{freeze_id}/confirm"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBalanceConfirmTransfer))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) CreateConsumersBalance(ctx context.Context, in *CreateConsumersBalanceRequest, opts ...http.CallOption) (*CreateConsumersBalanceReply, error) {
	var out CreateConsumersBalanceReply
	pattern := "/v1/balances/consumers/{user_id}/balance"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBalanceCreateConsumersBalance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) CreateMerchantBalance(ctx context.Context, in *CreateMerchantBalanceRequest, opts ...http.CallOption) (*CreateMerchantBalanceReply, error) {
	var out CreateMerchantBalanceReply
	pattern := "/v1/balances/merchants/{merchant_id}/balance"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBalanceCreateMerchantBalance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) CreateTransaction(ctx context.Context, in *CreateTransactionRequest, opts ...http.CallOption) (*CreateTransactionReply, error) {
	var out CreateTransactionReply
	pattern := "/v1/balances/transactions"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBalanceCreateTransaction))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) FreezeBalance(ctx context.Context, in *FreezeBalanceRequest, opts ...http.CallOption) (*FreezeBalanceReply, error) {
	var out FreezeBalanceReply
	pattern := "/v1/balances/freeze"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBalanceFreezeBalance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) GetMerchantBalance(ctx context.Context, in *GetMerchantBalanceRequest, opts ...http.CallOption) (*BalanceReply, error) {
	var out BalanceReply
	pattern := "/v1/balances/merchants/{merchant_id}/balance"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationBalanceGetMerchantBalance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) GetMerchantVersion(ctx context.Context, in *GetMerchantVersionRequest, opts ...http.CallOption) (*GetMerchantVersionReply, error) {
	var out GetMerchantVersionReply
	pattern := "/v1/orders/merchant/version"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationBalanceGetMerchantVersion))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) GetTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...http.CallOption) (*GetTransactionsReply, error) {
	var out GetTransactionsReply
	pattern := "/v1/balances/transactions"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationBalanceGetTransactions))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) GetUserBalance(ctx context.Context, in *GetUserBalanceRequest, opts ...http.CallOption) (*BalanceReply, error) {
	var out BalanceReply
	pattern := "/v1/balances/consumers/balance"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationBalanceGetUserBalance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) RechargeBalance(ctx context.Context, in *RechargeBalanceRequest, opts ...http.CallOption) (*RechargeBalanceReply, error) {
	var out RechargeBalanceReply
	pattern := "/v1/balances/consumers/recharge"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBalanceRechargeBalance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) RechargeMerchantBalance(ctx context.Context, in *RechargeMerchantBalanceRequest, opts ...http.CallOption) (*RechargeMerchantBalanceReply, error) {
	var out RechargeMerchantBalanceReply
	pattern := "/v1/balances/merchants/recharge"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBalanceRechargeMerchantBalance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) WithdrawBalance(ctx context.Context, in *WithdrawBalanceRequest, opts ...http.CallOption) (*WithdrawBalanceReply, error) {
	var out WithdrawBalanceReply
	pattern := "/v1/balances/consumers/withdraw"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBalanceWithdrawBalance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
