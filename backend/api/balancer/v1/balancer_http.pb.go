// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.4
// - protoc             v5.29.3
// source: v1/balancer.proto

package balancerv1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationBalanceCancelFreeze = "/ecommerce.balancer.v1.Balance/CancelFreeze"
const OperationBalanceConfirmTransfer = "/ecommerce.balancer.v1.Balance/ConfirmTransfer"
const OperationBalanceFreezeBalance = "/ecommerce.balancer.v1.Balance/FreezeBalance"
const OperationBalanceGetMerchantBalance = "/ecommerce.balancer.v1.Balance/GetMerchantBalance"
const OperationBalanceGetUserBalance = "/ecommerce.balancer.v1.Balance/GetUserBalance"
const OperationBalanceRechargeBalance = "/ecommerce.balancer.v1.Balance/RechargeBalance"
const OperationBalanceWithdrawBalance = "/ecommerce.balancer.v1.Balance/WithdrawBalance"

type BalanceHTTPServer interface {
	// CancelFreeze 取消冻结
	CancelFreeze(context.Context, *CancelFreezeRequest) (*CancelFreezeResponse, error)
	// ConfirmTransfer 确认转账（解冻并转给商家）
	ConfirmTransfer(context.Context, *ConfirmTransferRequest) (*ConfirmTransferResponse, error)
	// FreezeBalance 冻结用户余额
	FreezeBalance(context.Context, *FreezeBalanceRequest) (*FreezeBalanceResponse, error)
	// GetMerchantBalance 获取商家余额
	GetMerchantBalance(context.Context, *GetMerchantBalanceRequest) (*BalanceResponse, error)
	// GetUserBalance 获取用户余额
	GetUserBalance(context.Context, *GetUserBalanceRequest) (*BalanceResponse, error)
	// RechargeBalance 用户充值
	RechargeBalance(context.Context, *RechargeBalanceRequest) (*RechargeBalanceResponse, error)
	// WithdrawBalance 用户提现
	WithdrawBalance(context.Context, *WithdrawBalanceRequest) (*WithdrawBalanceResponse, error)
}

func RegisterBalanceHTTPServer(s *http.Server, srv BalanceHTTPServer) {
	r := s.Route("/")
	r.GET("/v1/balances/users/{user_id}/balance", _Balance_GetUserBalance0_HTTP_Handler(srv))
	r.POST("/v1/balances/freeze", _Balance_FreezeBalance0_HTTP_Handler(srv))
	r.POST("/v1/balances/freezes/{freeze_id}/confirm", _Balance_ConfirmTransfer0_HTTP_Handler(srv))
	r.POST("/v1/balances/freezes/{freeze_id}/cancel", _Balance_CancelFreeze0_HTTP_Handler(srv))
	r.GET("/v1/balances/merchants/{merchant_id}/balance", _Balance_GetMerchantBalance0_HTTP_Handler(srv))
	r.POST("/v1/balances/users/{user_id}/recharge", _Balance_RechargeBalance0_HTTP_Handler(srv))
	r.POST("/v1/balances/users/{user_id}/withdraw", _Balance_WithdrawBalance0_HTTP_Handler(srv))
}

func _Balance_GetUserBalance0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetUserBalanceRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceGetUserBalance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetUserBalance(ctx, req.(*GetUserBalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BalanceResponse)
		return ctx.Result(200, reply)
	}
}

func _Balance_FreezeBalance0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in FreezeBalanceRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceFreezeBalance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.FreezeBalance(ctx, req.(*FreezeBalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*FreezeBalanceResponse)
		return ctx.Result(200, reply)
	}
}

func _Balance_ConfirmTransfer0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ConfirmTransferRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceConfirmTransfer)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ConfirmTransfer(ctx, req.(*ConfirmTransferRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ConfirmTransferResponse)
		return ctx.Result(200, reply)
	}
}

func _Balance_CancelFreeze0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CancelFreezeRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceCancelFreeze)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CancelFreeze(ctx, req.(*CancelFreezeRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CancelFreezeResponse)
		return ctx.Result(200, reply)
	}
}

func _Balance_GetMerchantBalance0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetMerchantBalanceRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceGetMerchantBalance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetMerchantBalance(ctx, req.(*GetMerchantBalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BalanceResponse)
		return ctx.Result(200, reply)
	}
}

func _Balance_RechargeBalance0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RechargeBalanceRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceRechargeBalance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RechargeBalance(ctx, req.(*RechargeBalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RechargeBalanceResponse)
		return ctx.Result(200, reply)
	}
}

func _Balance_WithdrawBalance0_HTTP_Handler(srv BalanceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in WithdrawBalanceRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBalanceWithdrawBalance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.WithdrawBalance(ctx, req.(*WithdrawBalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*WithdrawBalanceResponse)
		return ctx.Result(200, reply)
	}
}

type BalanceHTTPClient interface {
	CancelFreeze(ctx context.Context, req *CancelFreezeRequest, opts ...http.CallOption) (rsp *CancelFreezeResponse, err error)
	ConfirmTransfer(ctx context.Context, req *ConfirmTransferRequest, opts ...http.CallOption) (rsp *ConfirmTransferResponse, err error)
	FreezeBalance(ctx context.Context, req *FreezeBalanceRequest, opts ...http.CallOption) (rsp *FreezeBalanceResponse, err error)
	GetMerchantBalance(ctx context.Context, req *GetMerchantBalanceRequest, opts ...http.CallOption) (rsp *BalanceResponse, err error)
	GetUserBalance(ctx context.Context, req *GetUserBalanceRequest, opts ...http.CallOption) (rsp *BalanceResponse, err error)
	RechargeBalance(ctx context.Context, req *RechargeBalanceRequest, opts ...http.CallOption) (rsp *RechargeBalanceResponse, err error)
	WithdrawBalance(ctx context.Context, req *WithdrawBalanceRequest, opts ...http.CallOption) (rsp *WithdrawBalanceResponse, err error)
}

type BalanceHTTPClientImpl struct {
	cc *http.Client
}

func NewBalanceHTTPClient(client *http.Client) BalanceHTTPClient {
	return &BalanceHTTPClientImpl{client}
}

func (c *BalanceHTTPClientImpl) CancelFreeze(ctx context.Context, in *CancelFreezeRequest, opts ...http.CallOption) (*CancelFreezeResponse, error) {
	var out CancelFreezeResponse
	pattern := "/v1/balances/freezes/{freeze_id}/cancel"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBalanceCancelFreeze))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) ConfirmTransfer(ctx context.Context, in *ConfirmTransferRequest, opts ...http.CallOption) (*ConfirmTransferResponse, error) {
	var out ConfirmTransferResponse
	pattern := "/v1/balances/freezes/{freeze_id}/confirm"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBalanceConfirmTransfer))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) FreezeBalance(ctx context.Context, in *FreezeBalanceRequest, opts ...http.CallOption) (*FreezeBalanceResponse, error) {
	var out FreezeBalanceResponse
	pattern := "/v1/balances/freeze"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBalanceFreezeBalance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) GetMerchantBalance(ctx context.Context, in *GetMerchantBalanceRequest, opts ...http.CallOption) (*BalanceResponse, error) {
	var out BalanceResponse
	pattern := "/v1/balances/merchants/{merchant_id}/balance"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationBalanceGetMerchantBalance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) GetUserBalance(ctx context.Context, in *GetUserBalanceRequest, opts ...http.CallOption) (*BalanceResponse, error) {
	var out BalanceResponse
	pattern := "/v1/balances/users/{user_id}/balance"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationBalanceGetUserBalance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) RechargeBalance(ctx context.Context, in *RechargeBalanceRequest, opts ...http.CallOption) (*RechargeBalanceResponse, error) {
	var out RechargeBalanceResponse
	pattern := "/v1/balances/users/{user_id}/recharge"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBalanceRechargeBalance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *BalanceHTTPClientImpl) WithdrawBalance(ctx context.Context, in *WithdrawBalanceRequest, opts ...http.CallOption) (*WithdrawBalanceResponse, error) {
	var out WithdrawBalanceResponse
	pattern := "/v1/balances/users/{user_id}/withdraw"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBalanceWithdrawBalance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
