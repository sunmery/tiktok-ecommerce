# é»˜è®¤å€¼
VERSION ?= dev
GOIMAGE ?= golang:1.24.2-alpine3.21
GOOS ?= linux
GOARCH ?= amd64
CGOENABLED ?= 0

# åŠ¨æ€å˜é‡
DOCKER_IMAGE=e-commerce/$(APP_NAME):$(VERSION)
SERVICE = $(APP_RELATIVE_PATH)
REPOSITORY = sumery/$(SERVICE)
REGISTER = ccr.ccs.tencentyun.com
ARM64=linux/arm64
AMD64=linux/amd64

GOPATH:=$(shell go env GOPATH)
VERSION=$(shell git describe --tags --always)
APP_RELATIVE_PATH=$(shell basename $$PWD)
API_PROTO_FILES=$(shell cd ../../api/$(APP_RELATIVE_PATH) && find . -name *.proto)
INTERNAL_PROTO_FILES=$(shell find internal -name *.proto)
APP_NAME=$(APP_RELATIVE_PATH)

.PHONY: run stop

# å¯åŠ¨æ‰€æœ‰æœåŠ¡
.PHONY: run stop

# å¯åŠ¨æ‰€æœ‰æœåŠ¡
run:
	@echo "Starting all services..."
	@rm -f .pids  # æ¸…ç†æ—§çš„ PID æ–‡ä»¶
	@cd application/auth && config_center=$(CONFIG_CENTER) kratos run & echo $$! >> .pids && sleep 1 && \
	cd application/user && config_center=$(CONFIG_CENTER) kratos run & echo $$! >> .pids && sleep 1 && \
	cd application/category && config_center=$(CONFIG_CENTER) kratos run & echo $$! >> .pids && sleep 1 && \
	cd application/product && config_center=$(CONFIG_CENTER) kratos run & echo $$! >> .pids && sleep 1 && \
	cd application/cart && config_center=$(CONFIG_CENTER) kratos run & echo $$! >> .pids && sleep 1 && \
	cd application/checkout && config_center=$(CONFIG_CENTER) kratos run & echo $$! >> .pids && sleep 1 && \
	cd application/order && config_center=$(CONFIG_CENTER) kratos run & echo $$! >> .pids && sleep 1 && \
	cd application/payment && config_center=$(CONFIG_CENTER) kratos run & echo $$! >> .pids
	@echo "All services started. Use 'make stop' to stop them."

# åœæ­¢æ‰€æœ‰æœåŠ¡
stop:
	@echo "Stopping all services..."
	@if [ -f .pids ]; then \
		while read pid; do \
			if ps -p $$pid > /dev/null; then \
				kill $$pid || kill -15 $$pid; \
				echo "Stopped process $$pid"; \
			else \
				echo "Process $$pid not found"; \
			fi; \
		done < .pids; \
		rm -f .pids; \
		echo "All services stopped."; \
	else \
		echo "No services running."; \
	fi

.PHONY: api
# ç”Ÿæˆapiç›®å½•çš„protoçš„ä»£ç 
api:
	@cd ../../api/$(APP_RELATIVE_PATH) && \
	protoc --proto_path=../../.. \
	--proto_path=. \
	--proto_path=../../third_party \
	--go_out=paths=source_relative:. \
	--go-http_out=paths=source_relative:. \
	--go-grpc_out=paths=source_relative:. \
	--go-errors_out=paths=source_relative:. \
	--validate_out=paths=source_relative,lang=go:. \
	--openapiv2_out=. \
	$(API_PROTO_FILES) && echo "ok, no err"

.PHONY: infra
# å¯åŠ¨åŸºç¡€è®¾æ–½
infra:
	docker compose -f infrastructure/consul/compose.yaml up -d
	docker compose -f infrastructure/citus/compose.yaml up -d
	docker compose -f infrastructure/dragonflydb/compose.yaml up -d
	docker compose -f infrastructure/minio/compose.yaml up -d

.PHONY: config
# é‡æ–°ç”Ÿæˆprotoçš„é…ç½®
config:
	@protoc --proto_path=. \
    --proto_path=../../third_party \
    --go_out=paths=source_relative:. \
    $(INTERNAL_PROTO_FILES)

.PHONY: validate
# ç”Ÿæˆprotoå‚æ•°æ ¡éªŒ
validate:
	@cd ../../api/$(APP_RELATIVE_PATH) && \
	protoc --proto_path=../../.. \
	--proto_path=. \
	--proto_path=../../third_party \
    --go_out=paths=source_relative:. \
	--validate_out=paths=source_relative,lang=go:. \
	$(API_PROTO_FILES) && echo "ok, no err"

.PHONY: build
# æ„å»º $(APP_NAME) åº”ç”¨ç‰ˆæœ¬: $(VERSION)
build:
	@echo "æ„å»º $(APP_NAME) åº”ç”¨ç‰ˆæœ¬: $(VERSION)"
	mkdir -p bin/ && go build -ldflags "-X main.Version=$(VERSION)" -o ./bin/ ./...

.PHONY: docker-build
# ä½¿ç”¨ docker æ„å»ºé•œåƒ
docker-build:
	@echo "æ„å»ºçš„å¾®æœåŠ¡: $(SERVICE)"
	@echo "ç³»ç»Ÿ: $(GOOS) | CPUæ¶æ„: $(GOARCH)"
	@echo "é•œåƒå: $(REPOSITORY):$(VERSION)"
	docker build . \
	  -f application/$(SERVICE)/Dockerfile \
	  --progress=plain \
	  -t ecommerce/$(SERVICE):$(VERSION) \
	  --build-arg SERVICE=$(SERVICE) \
	  --build-arg CGOENABLED=$(CGOENABLED) \
	  --build-arg GOIMAGE=$(GOIMAGE) \
	  --build-arg GOOS=$(GOOS) \
	  --build-arg GOARCH=$(GOARCH) \
	  --build-arg VERSION=$(VERSION) \
	  --platform $(GOOS)/$(GOARCH)  \
	  --cache-from type=registry,ref=$(REGISTER)/$(REPOSITORY):cache \
	  --cache-to type=registry,ref=$(REGISTER)/$(REPOSITORY):cache,mode=max

.PHONY: docker-deployx
# ä½¿ç”¨ docker æ„å»ºå¤šå¹³å°æ¶æ„é•œåƒ
docker-deployx:
	@echo "æ„å»ºçš„å¾®æœåŠ¡: $(SERVICE)"
	@echo "å¹³å°1: $(ARM64)"
	@echo "å¹³å°2: $(AMD64)"
	@echo "é•œåƒå: $(REPOSITORY):$(VERSION)"
	docker buildx build . \
	  -f application/$(SERVICE)/Dockerfile \
	  --progress=plain \
	  -t $(REGISTER)/$(REPOSITORY):$(VERSION) \
	  --build-arg SERVICE=$(SERVICE) \
	  --build-arg CGOENABLED=$(CGOENABLED) \
	  --build-arg GOIMAGE=$(GOIMAGE) \
	  --build-arg VERSION=$(VERSION) \
	  --platform $(ARM64),$(AMD64) \
	  --push \
	  --cache-from type=registry,ref=$(REGISTER)/$(REPOSITORY):cache \
	  --cache-to type=registry,ref=$(REGISTER)/$(REPOSITORY):cache,mode=max


# ä½¿ç”¨æ–¹å¼: make docker-push SERVICE=å¾®æœåŠ¡å
.PHONY: docker-push
docker-push:
	@echo "ä½¿ç”¨æ–¹å¼: make docker-push SERVICE=å¾®æœåŠ¡å"
	@echo "OS: $(GOOS) | ARCH: $(GOARCH)"
	@echo "Docker image: $(REPOSITORY):$(VERSION)"
	docker tag ecommerce/$(SERVICE):$(VERSION) $(REGISTER)/$(REPOSITORY):$(VERSION)
	docker push $(REGISTER)/$(REPOSITORY):$(VERSION)

.PHONY: docker-deploy
docker-deploy:
	@echo "ä½¿ç”¨æ–¹å¼: make docker-deploy SERVICE=å¾®æœåŠ¡å"
	@echo "SERVICE=$(SERVICE)"
	make docker-build SERVICE=$(SERVICE)
	@echo "SERVICE=$(SERVICE)"
	make docker-push SERVICE=$(SERVICE)

SERVICES := auth user product cart order checkout payment category merchant admin comment balancer consumer
CONCURRENT_JOBS := 5

.PHONY: deploy-all clean-status

deploy-all: clean-status
	@echo "=== Starting parallel deployment (max ${CONCURRENT_JOBS} jobs) ==="
	@mkdir -p .status
	@# ä½¿ç”¨å¹¶è¡Œä»»åŠ¡æ§åˆ¶
	@for service in $(SERVICES); do \
		echo "ğŸš€ Scheduling: $$service"; \
	done
	@# ä½¿ç”¨GNU parallelæ›¿ä»£xargs
	@parallel -j $(CONCURRENT_JOBS) --halt soon,fail=1 --joblog .status/jobs.log \
		"$(MAKE) _deploy-single SERVICE={1} GOOS='$(GOOS)' GOARCH='$(GOARCH)'" ::: $(SERVICES)
	@# ç”Ÿæˆæœ€ç»ˆç»“æœæŠ¥å‘Š
	@make show-results
	@exit $$(cat .status/exitcode)

# å®é™…éƒ¨ç½²ä»»åŠ¡ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
_deploy-single:
	@echo "ğŸ”§ Starting deployment: $(SERVICE)"
	@ts=$$(date +%s); \
	if $(MAKE) docker-deploy SERVICE=$(SERVICE) 2>&1 | tee .status/$(SERVICE).log; then \
		echo "âœ… Success: $(SERVICE) ($$(($$(date +%s)-ts))s" > .status/$(SERVICE); \
	else \
		echo "âŒ Failed: $(SERVICE) ($$(($$(date +%s)-ts))s" > .status/$(SERVICE); \
		echo 1 > .status/exitcode; \
		exit 1; \
	fi

# æ”¹è¿›çš„çŠ¶æ€æ˜¾ç¤º
show-results:
	@clear
	@total=$$(echo $(SERVICES) | wc -w); \
	while [ $$(ls .status | grep -v -e exitcode -e jobs.log | wc -l) -lt $$total ]; do \
		clear; \
		echo "=== Deployment Progress [$$(date +%T)] ==="; \
		for service in $(SERVICES); do \
			if [ -f ".status/$$service" ]; then \
				status=$$(awk '{print $$1}' .status/$$service); \
				time=$$(awk '{print $$3}' .status/$$service); \
				echo "$$status | $$service | â±ï¸ $${time}"; \
			else \
				echo "ğŸ•’ Pending | $$service | --"; \
			fi; \
		done; \
		echo "Completed: $$(ls .status | grep -v -e exitcode -e jobs.log | wc -l)/$$total"; \
		sleep 1; \
	done
	@echo "=== Final Results ==="
	@cat .status/* | grep -v exitcode
	@echo "Exit code: $$(cat .status/exitcode)"

clean-status:
	@rm -rf .status
	@mkdir -p .status
	@echo 0 > .status/exitcode

.PHONY: generate
# generate client code
generate:
	go generate ./...

.PHONY: wire
# generate wire
wire:
	go generate ./...

.PHONY: test
# test go file
test:
	@echo "æµ‹è¯• $(APP_NAME) æ­£åœ¨è¾“å‡ºè¦†ç›–ç‡å’ŒæŸ¥æ‰¾æ½œåœ¨çš„goruntineç«äº‰"
	go test -v ./... -cover -race

.PHONY: all
# ç”Ÿæˆå…¨éƒ¨ä»£ç 
all:
	@make api
	@make config
	@make wire
	@make sqlc
	@echo "ok, no err"

.PHONY: migrate-new
# ç”Ÿæˆè¿ç§»æ–‡ä»¶, example: make migrate-new name=verify_emails
migrate-new:
	migrate create -dir internal/data/migrate -ext sql -seq $(name)

.PHONY: migrate-up
# å‡çº§å…¨éƒ¨çš„è¿ç§»æ–‡ä»¶, å…ˆå®‰è£…https://github.com/golang-migrate/migrate/tree/master
migrate-up:
	#export DB_SOURCE="postgresql://postgres:postgres@localhost:5432/ecommerce?sslmode=disable"
	migrate -database "${DB_SOURCE}" -path internal/data/migrate -verbose up

.PHONY: migrate-up1
# å‘ä¸Šè¿ç§»ä¸€ä¸ªç‰ˆæœ¬, æ ¹æ®æ•°æ®åº“çš„è¡¨schema_migrationsçš„versionæ¥å†³å®š
migrate-up1:
	migrate -database "${DB_SOURCE}" -path internal/data/migrate -verbose up 1

.PHONY: migrate-down
# å‘ä¸‹å…¨éƒ¨é™çº§è¿ç§»æ–‡ä»¶, å…ˆå®‰è£…https://github.com/golang-migrate/migrate/tree/master
migrate-down:
	migrate -database "${DB_SOURCE}" -path internal/data/migrate -verbose down

.PHONY: migrate-down1
# å‘ä¸‹é™çº§ä¸€ä¸ªç‰ˆæœ¬, æ ¹æ®æ•°æ®åº“çš„è¡¨schema_migrationsçš„versionæ¥å†³å®š
migrate-down1:
	migrate -database "${DB_SOURCE}" -path internal/data/migrate -verbose down 1

.PHONY: mock
# Mock DB -package åŒ…å -destination åŒ…å«ç”Ÿæˆçš„mockæ–‡ä»¶ä½ç½® dir/dir TaskDistributor æœ€åå‚æ•°: åŒ…è·¯å¾„ä¸è¦ç”Ÿæˆçš„interfaceæ¥å£çš„åç§°
mock:
	mockgen -package mockdb -destination mock/store.go example/sqlc Store

.PHONY: evans
# grpcçš„å‘½ä»¤è¡Œæµ‹è¯•å·¥å…·
evans:
	evans -r repl --host localhost -p $(GRPC_PROT)

.PHONY: sqlc
# ç”Ÿæˆsqlä»£ç 
sqlc:
	rm -rf internal/data/models/*
	sqlc generate

.PHONY: help
# show help
help:
	@echo ''
	@echo 'Usage:'
	@echo ' make [target]'
	@echo ''
	@echo 'Targets:'
	@awk '/^[a-zA-Z\-\_0-9]+:/ { \
	helpMessage = match(lastLine, /^# (.*)/); \
		if (helpMessage) { \
			helpCommand = substr($$1, 0, index($$1, ":")-1); \
			helpMessage = substr(lastLine, RSTART + 2, RLENGTH); \
			printf "\033[36m%-22s\033[0m %s\n", helpCommand,helpMessage; \
		} \
	} \
	{ lastLine = $$0 }' $(MAKEFILE_LIST)

.DEFAULT_GOAL := help
